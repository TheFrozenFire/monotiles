use crate::coxeter::{CoxeterElement, Generator};
use std::collections::HashSet;
use Generator::*;

/// The 16-element Cucaracha: a mildly aperiodic monotile of the Coxeter group Gamma.
///
/// Obtained by applying the discretization functor Psi to the hat tile.
/// Elements are words of length <= 4 in {alpha, beta, gamma}, listed as:
/// {1, α, β, γ, αβ, βα, βγ, γβ, αβα, βαβ, βαγ, βγβ, γβα, αβαβ, βαγβ, γβαβ}
///
/// Reference: Coulbois, Gajardo, Guillon, Lutfalla (2024), "Aperiodic monotiles:
/// from geometry to groups", arXiv:2409.15880.
pub const CUCARACHA_WORDS: [&[Generator]; 16] = [
    &[],                                 // 1 (identity)
    &[Alpha],                            // α
    &[Beta],                             // β
    &[Gamma],                            // γ
    &[Alpha, Beta],                      // αβ
    &[Beta, Alpha],                      // βα
    &[Beta, Gamma],                      // βγ
    &[Gamma, Beta],                      // γβ
    &[Alpha, Beta, Alpha],              // αβα
    &[Beta, Alpha, Beta],               // βαβ
    &[Beta, Alpha, Gamma],              // βαγ
    &[Beta, Gamma, Beta],               // βγβ
    &[Gamma, Beta, Alpha],              // γβα
    &[Alpha, Beta, Alpha, Beta],        // αβαβ
    &[Beta, Alpha, Gamma, Beta],        // βαγβ
    &[Gamma, Beta, Alpha, Beta],        // γβαβ
];

/// Compute the 16 Cucaracha elements in normal form.
pub fn cucaracha() -> [CoxeterElement; 16] {
    let mut result = [CoxeterElement::identity(); 16];
    for (i, word) in CUCARACHA_WORDS.iter().enumerate() {
        result[i] = CoxeterElement::from_generators(word);
    }
    result
}

/// A cotiler: a set of group elements g such that {g * c : c in Cucaracha}
/// partitions a region of Gamma.
///
/// The possible stabilizers of Cucaracha cotilers are {id} or conjugates of
/// {id, R_3, R_3^2} (3-fold rotational symmetry).
#[derive(Clone, Debug)]
pub struct Cotiler {
    pub positions: Vec<CoxeterElement>,
}

impl Cotiler {
    pub fn new(positions: Vec<CoxeterElement>) -> Self {
        Self { positions }
    }

    /// Check that no two translated copies of the Cucaracha overlap.
    /// Returns true if all tile placements are pairwise disjoint.
    pub fn is_non_overlapping(&self) -> bool {
        let tile = cucaracha();
        let mut all_cells = std::collections::HashSet::new();
        for pos in &self.positions {
            for cell in &tile {
                let placed = pos.compose(cell);
                if !all_cells.insert(placed) {
                    return false;
                }
            }
        }
        true
    }

    /// Count the total number of cells covered by this cotiler.
    pub fn cell_count(&self) -> usize {
        self.positions.len() * 16
    }

    /// All group elements (cells) covered by this cotiler.
    pub fn covered_cells(&self) -> HashSet<CoxeterElement> {
        let tile = cucaracha();
        let mut cells = HashSet::new();
        for pos in &self.positions {
            for cell in &tile {
                cells.insert(pos.compose(cell));
            }
        }
        cells
    }

    /// Check if the cotiler fully covers a given set of target cells.
    pub fn covers(&self, targets: &HashSet<CoxeterElement>) -> bool {
        let cells = self.covered_cells();
        targets.is_subset(&cells)
    }

    /// Extract the n-neighborhood of a position in this cotiler.
    ///
    /// The n-neighborhood of position `g` is the set of cotiler positions `h`
    /// such that the tiles at `g` and `h` are within distance n (share cells
    /// reachable in at most n generator steps).
    ///
    /// For n=1, this returns positions whose tiles share a boundary cell with
    /// the tile at `center`.
    pub fn neighborhood(&self, center: &CoxeterElement, n: usize) -> Vec<CoxeterElement> {
        let tile = cucaracha();

        // Expand the center tile's cells by n generator steps
        let center_cells: HashSet<_> = tile.iter().map(|c| center.compose(c)).collect();
        let expanded = expand_by_generators(&center_cells, n);

        // Find positions whose tiles intersect the expanded region
        self.positions
            .iter()
            .filter(|pos| {
                if *pos == center {
                    return false; // exclude self
                }
                tile.iter().any(|c| expanded.contains(&pos.compose(c)))
            })
            .copied()
            .collect()
    }

    /// Compute the cotiler group G_C = <g * h^{-1} | g, h in positions>.
    ///
    /// This is the group generated by all pairwise quotients of cotiler positions.
    /// For the Cucaracha, the cotiler group reveals the translation symmetries
    /// of the tiling.
    ///
    /// Returns generators (not the full group, which may be infinite).
    pub fn cotiler_group_generators(&self) -> Vec<CoxeterElement> {
        let mut generators = HashSet::new();
        for g in &self.positions {
            for h in &self.positions {
                if g != h {
                    let gh_inv = g.compose(&h.inverse());
                    if gh_inv != CoxeterElement::identity() {
                        generators.insert(gh_inv);
                    }
                }
            }
        }
        generators.into_iter().collect()
    }

    /// Compute the stabilizer of this cotiler: elements g in Gamma such that
    /// g * C = C (left-multiplying every position by g permutes the positions).
    ///
    /// Searches among the D₆ point group elements and small translations.
    /// For the Cucaracha, possible stabilizers are {id} or conjugates of
    /// {id, R₃, R₃²} (3-fold rotational symmetry).
    pub fn stabilizer(&self) -> Vec<CoxeterElement> {
        let pos_set: HashSet<_> = self.positions.iter().collect();
        let candidates = CoxeterElement::point_group_elements();

        candidates
            .iter()
            .filter(|g| {
                self.positions
                    .iter()
                    .all(|p| pos_set.contains(&g.compose(p)))
            })
            .copied()
            .collect()
    }

    /// Check if this cotiler is valid: non-overlapping with contiguous coverage.
    pub fn is_valid(&self) -> bool {
        self.is_non_overlapping()
    }
}

/// Expand a set of cells by n steps of generator application.
///
/// At each step, every cell in the set is composed with each Coxeter generator
/// (and its inverse), expanding the frontier.
fn expand_by_generators(cells: &HashSet<CoxeterElement>, n: usize) -> HashSet<CoxeterElement> {
    let generators = [
        CoxeterElement::generator(Generator::Alpha),
        CoxeterElement::generator(Generator::Beta),
        CoxeterElement::generator(Generator::Gamma),
    ];

    let mut expanded = cells.clone();
    let mut frontier = cells.clone();

    for _ in 0..n {
        let mut new_frontier = HashSet::new();
        for cell in &frontier {
            for gen in &generators {
                // Generators are involutions (self-inverse), so only need one direction
                let neighbor = cell.compose(gen);
                if expanded.insert(neighbor) {
                    new_frontier.insert(neighbor);
                }
            }
        }
        frontier = new_frontier;
    }

    expanded
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cucaracha_has_16_distinct_elements() {
        let elements = cucaracha();
        let unique: std::collections::HashSet<_> = elements.iter().collect();
        assert_eq!(unique.len(), 16);
    }

    #[test]
    fn cucaracha_contains_identity() {
        let elements = cucaracha();
        assert!(elements.contains(&CoxeterElement::identity()));
    }

    #[test]
    fn cucaracha_contains_all_generators() {
        let elements = cucaracha();
        assert!(elements.contains(&CoxeterElement::generator(Alpha)));
        assert!(elements.contains(&CoxeterElement::generator(Beta)));
        assert!(elements.contains(&CoxeterElement::generator(Gamma)));
    }

    #[test]
    fn cucaracha_word_lengths_are_at_most_four() {
        for word in &CUCARACHA_WORDS {
            assert!(word.len() <= 4, "word too long: {:?}", word);
        }
    }

    #[test]
    fn cucaracha_normal_forms_match_expected() {
        let elements = cucaracha();

        // Verify specific known normal forms
        assert_eq!(elements[0], CoxeterElement::new(0, 0, 0, false)); // id
        assert_eq!(elements[1], CoxeterElement::new(0, 0, 0, true)); // α
        assert_eq!(elements[2], CoxeterElement::new(0, 0, 1, true)); // β
        assert_eq!(elements[3], CoxeterElement::new(1, 0, 3, true)); // γ
        assert_eq!(elements[4], CoxeterElement::new(0, 0, 5, false)); // αβ
        assert_eq!(elements[5], CoxeterElement::new(0, 0, 1, false)); // βα
        assert_eq!(elements[6], CoxeterElement::new(0, 1, 4, false)); // βγ
        assert_eq!(elements[7], CoxeterElement::new(1, 0, 2, false)); // γβ
    }

    #[test]
    fn single_tile_is_non_overlapping() {
        let cotiler = Cotiler::new(vec![CoxeterElement::identity()]);
        assert!(cotiler.is_non_overlapping());
        assert_eq!(cotiler.cell_count(), 16);
    }

    #[test]
    fn cucaracha_elements_closed_under_left_action() {
        let elements = cucaracha();
        let composed: Vec<CoxeterElement> = elements
            .iter()
            .map(|c| CoxeterElement::identity().compose(c))
            .collect();
        let unique: HashSet<_> = composed.iter().collect();
        assert_eq!(unique.len(), 16);
    }

    #[test]
    fn covered_cells_for_single_tile() {
        let cotiler = Cotiler::new(vec![CoxeterElement::identity()]);
        let cells = cotiler.covered_cells();
        assert_eq!(cells.len(), 16);
    }

    #[test]
    fn two_adjacent_tiles_non_overlapping() {
        // Place a second tile by translating far enough that cells don't overlap
        let pos2 = CoxeterElement::new(5, 5, 0, false);
        let cotiler = Cotiler::new(vec![CoxeterElement::identity(), pos2]);
        assert!(cotiler.is_non_overlapping());
        assert_eq!(cotiler.cell_count(), 32);
    }

    #[test]
    fn overlapping_detected() {
        // Place two tiles at the same position -> overlap
        let cotiler = Cotiler::new(vec![
            CoxeterElement::identity(),
            CoxeterElement::identity(),
        ]);
        assert!(!cotiler.is_non_overlapping());
    }

    #[test]
    fn neighborhood_excludes_self() {
        let center = CoxeterElement::identity();
        let cotiler = Cotiler::new(vec![center]);
        let neighbors = cotiler.neighborhood(&center, 1);
        assert!(neighbors.is_empty());
    }

    #[test]
    fn neighborhood_finds_adjacent() {
        // Place two tiles near each other. Use generator alpha = (0,0,0,true)
        // which is in the Cucaracha, so the tile at alpha^{-1} = alpha
        // will share the identity cell with the tile at id.
        let center = CoxeterElement::identity();
        // Place a tile one generator step away from a Cucaracha cell
        let tile = cucaracha();
        // Pick a cell on the boundary of the center tile and place a new tile
        // such that it shares a generator-neighbor
        let boundary_cell = tile[3]; // gamma = (1,0,3,true)
        let gen_alpha = CoxeterElement::generator(Alpha);
        // step one generator beyond the boundary
        let far_cell = boundary_cell.compose(&gen_alpha);
        // Place the second tile at far_cell * inverse(tile[0]) = far_cell
        let neighbor_pos = far_cell;
        let cotiler = Cotiler::new(vec![center, neighbor_pos]);

        // The tiles share a generator-adjacent cell, so n=1 should find it
        let neighbors = cotiler.neighborhood(&center, 1);
        assert!(
            neighbors.contains(&neighbor_pos),
            "nearby tile at {:?} should be in 1-neighborhood, got {:?}",
            neighbor_pos,
            neighbors
        );
    }

    #[test]
    fn cotiler_group_generators_for_single_tile() {
        let cotiler = Cotiler::new(vec![CoxeterElement::identity()]);
        let gens = cotiler.cotiler_group_generators();
        assert!(gens.is_empty(), "single tile has no nontrivial generators");
    }

    #[test]
    fn cotiler_group_generators_nontrivial() {
        let a = CoxeterElement::identity();
        let b = CoxeterElement::new(3, 0, 0, false);
        let cotiler = Cotiler::new(vec![a, b]);
        let gens = cotiler.cotiler_group_generators();
        assert!(!gens.is_empty());

        // Should contain b * a^{-1} = b and a * b^{-1} = b^{-1}
        assert!(gens.contains(&b));
        assert!(gens.contains(&b.inverse()));
    }

    #[test]
    fn stabilizer_of_single_tile_is_identity() {
        let cotiler = Cotiler::new(vec![CoxeterElement::identity()]);
        let stab = cotiler.stabilizer();
        assert_eq!(stab, vec![CoxeterElement::identity()]);
    }

    #[test]
    fn stabilizer_of_r3_symmetric_cotiler() {
        // Construct a cotiler with 3-fold rotational symmetry (R₃ = R₆²)
        let r2 = CoxeterElement::new(0, 0, 2, false); // R₆²
        let r4 = CoxeterElement::new(0, 0, 4, false); // R₆⁴
        let cotiler = Cotiler::new(vec![
            CoxeterElement::identity(),
            r2,
            r4,
        ]);
        let stab = cotiler.stabilizer();
        // Should contain {id, R₆², R₆⁴}
        assert!(stab.contains(&CoxeterElement::identity()));
        assert!(stab.contains(&r2));
        assert!(stab.contains(&r4));
        assert_eq!(stab.len(), 3);
    }

    #[test]
    fn expand_by_generators_grows() {
        let start: HashSet<_> = [CoxeterElement::identity()].into_iter().collect();
        let expanded_0 = super::expand_by_generators(&start, 0);
        let expanded_1 = super::expand_by_generators(&start, 1);
        let expanded_2 = super::expand_by_generators(&start, 2);
        assert_eq!(expanded_0.len(), 1);
        // After 1 step: identity + 3 generators (alpha, beta, gamma are involutions)
        assert_eq!(expanded_1.len(), 4);
        assert!(expanded_1.len() < expanded_2.len());
    }
}
