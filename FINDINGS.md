# Findings: Experimental Results from Monotile Exploration

Empirical results from running experiments on the hat monotile and its algebraic structure. These are things we measured, not things we read.

## Deflation Is Not a One-Way Function (#5)

The inflation/deflation asymmetry in the hat metatile substitution system does **not** constitute a computationally one-way function. Deflation is locally solvable.

### Results (hat and spectre, depth 3)

| Analysis | Hat | Spectre |
|----------|-----|---------|
| Full sibling adjacency | All tiles determined, radius ≤ 1 | All tiles determined, radius ≤ 1 |
| Inflation adjacency | All tiles determined, radius ≤ 4 | All tiles determined, radius ≤ 1 |
| Type-bag decomposition | Always unique (det(M) = -1) | Always unique (det(M) = 1) |
| Greedy deflation | 100% assignment rate | 100% assignment rate |

The asymmetry between inflation (O(n) local rule application) and deflation (recovering supertile boundaries) is **implementation convenience, not computational hardness**. A radius-1 neighborhood in the full sibling adjacency graph suffices to determine parent assignments for every tile.

The hat's inflation adjacency graph requires radius 4 because H-supertiles are disconnected in this sparser graph — some children lack intra-supertile neighbors. But this is an artifact of the graph choice, not an inherent barrier. The spectre, with its simpler 2-type system, resolves everything at radius 1 even with inflation adjacency.

## The Local-to-Global Gap Is All-or-Nothing (#6)

The gap between local indistinguishability and global rigidity in hierarchical substitution tilings closes as a **sharp phase transition**, not a gradual curve.

### Distinguishing advantage by radius (hat and spectre, depth 3)

| Radius | Hat Advantage | Spectre Advantage | Hat Normalized MI |
|--------|--------------|-------------------|-------------------|
| 0 | 0.0% | 0.0% | 0.000 |
| 1 | 0.0% | 0.0% | 0.001 |
| 2 | 1.0% | 0.0% | 0.055 |
| 3 (=depth) | **100.0%** | **100.0%** | **1.000** |

At every radius below depth, advantage is ~0%. At radius = depth, it jumps to 100% in a single step. Both hat and spectre exhibit identical transition behavior.

### Why the transition is sharp

The substitution is **recursively self-similar**: the local structure within any finite subtree is fully determined by the subtree root's type, independent of what's above it in the hierarchy. Two tiles from different seeds but with the same ancestor chain up to level k are locally indistinguishable at radius k. Only when the chain reaches the seed does the difference become visible.

The BFS-based type signature makes this even starker: with sibling adjacency, a tile can determine its immediate parent type at radius 1, but **cannot determine any higher ancestor** regardless of radius. The adjacency graph is disconnected at supertile boundaries, creating an absolute information barrier.

### Ancestry determination (hat, depth 3, seed H)

| Level | Relation | Determined | Fraction |
|-------|----------|------------|----------|
| 1 | Parent | 442/442 | 100% at radius 1 |
| 2 | Grandparent | 3/442 | 0.7% — nearly all undetermined |
| 3 | Seed | 442/442 | 100% (trivially, only one seed type) |

This demonstrates the BFS information barrier: sibling adjacency reveals parent type but nothing higher.

### Mutual information reveals partial structure

While distinguishing advantage is 0 for radii < depth, **mutual information** is nonzero starting at radius 1-2. The *distribution* of tiles across signatures varies by seed even when no individual signature is unique. A Bayesian observer gains partial information before the gap closes; a deterministic algorithm cannot.

### Connection to proximity gaps

The tiling gap is **dual** to the proximity gap in FRI/coding theory:
- **Proximity gap**: globally invalid → locally detectable (local tests are powerful)
- **Tiling gap**: globally different → locally undetectable until threshold (local observations are weak)

Both exhibit sharp transitions. The proximity gap makes the IOP verifier efficient; the tiling gap characterizes the cost of identification.

### Implications

The gap is **not suitable as a smooth hardness assumption** like LWE. It's a binary property: either you can see the seed (trivially easy) or you can't (information-theoretically impossible). More like a one-time pad than a lattice problem — unconditional but non-tunable.

For the IOP construction, this is ideal: the hierarchical commitment is unconditionally binding within any finite radius, and efficiency comes from the proximity gap on the proof side.

## Group Cryptography on Gamma = Z² ⋊ D₆ Is Not Viable (#8)

We tested three candidate hard problems for the Cucaracha's Coxeter group Gamma, motivated by the question of whether the tiling constraint could inject hardness into an otherwise tractable group.

### Cotiler Recovery

Given the cotiler group G_C (generated by pairwise quotients of tile positions), recover the cotiler C (up to translation).

| Size | Brute-force time | Solutions | Notes |
|------|-----------------|-----------|-------|
| 1 | 0.00 ms | 1 | Trivial |
| 2 | ~0.2 ms | 1-2 | Fast |
| 3 | ~3 ms | 3 | Fast |
| 4 | ~50 ms | 2-4 | Manageable |
| 5 | ~6,000 ms | 1-5 | Exponential blowup begins |
| 6 | >31,000 ms | budget exceeded (10M nodes) | Combinatorial explosion |

The bottleneck is C(candidates, n-1) where candidates grow as ~n²×4. At size 6, the candidate pool reaches ~136 elements, giving C(136, 5) ≈ 500M subsets to check.

**Coset decomposition doesn't help.** We implemented a coset-based algorithm that groups candidates by their Z² translation component and backtracks over translation classes (at most 12 D₆ decorations each). Result: ~1.0x speedup across all sizes. The translation classes are too numerous — there are roughly as many classes as individual candidates, so the grouping provides no reduction.

### Region Decomposition (Exact Cover)

Given the covered cells (forgetting tile boundaries), recover which tiles placed them.

| Size | Mean time | Solutions | Notes |
|------|-----------|-----------|-------|
| 1-20 | 0.00-0.07 ms | always exactly 1 | Linear scaling |

Trivially easy at all tested sizes. The Cucaracha's shape is sufficiently constrained that backtracking with a most-constrained-cell heuristic finds the unique decomposition almost immediately.

### Stabilizer Statistics

Compute the symmetry group of a random cotiler.

| Size | Trials | Trivial (|Stab|=1) | Threefold (|Stab|=3) |
|------|--------|-------------------|---------------------|
| 1-20 | 10 each | 100% | 0% |

All 200 random cotilers tested had trivial stabilizer. The threefold symmetry (rotation by 120°) that is theoretically possible never appeared in random growth.

### Verdict

All three problems are easy or show only brute-force combinatorial hardness (not algebraic hardness). The virtually abelian structure of Gamma = Z² ⋊ D₆ makes group-theoretic hard problems (word problem, conjugacy problem) trivially solvable. The tiling constraint adds a geometric overlap check but does not create cryptographically useful hardness — it's an NP-style constraint satisfaction problem, not a one-way function.

The recovery scaling is exponential in cotiler size, but this is a consequence of naive subset enumeration over a polynomially-growing candidate pool, not of any deep algebraic structure. The coset comparison confirms this: exploiting the group's Z² ⋊ D₆ decomposition provides zero speedup because the hardness was never group-theoretic to begin with.

## Erasure Resilience and the P'↔F' Vulnerability

The hat tiling's recoverability has a specific structural weakness and a graceful degradation profile under random erasure.

### The only confusable pair: P' and F'

Of all four supertile types, only one valid single-tile swap exists: P' (5 children) + 1 F-tile = F' (6 children). Their child type-bags differ by exactly one F-tile, so a P-supertile can be misidentified as an F-supertile if its boundary F-tile is present.

Despite this, **zero child positions are critical** — every position in every supertile type is individually redundant. The minimum determining sets are:

| Supertile | Children | Min determining set | Key |
|-----------|----------|-------------------|-----|
| H' | 10 | 1 tile (pos 3, a T) | T only appears in H-supertiles |
| T' | 1 | 1 tile (pos 0, an H) | Only 1 child total |
| P' | 5 | All 5 | Confusable with F' |
| F' | 6 | All 6 | Confusable with P' |

### Erasure threshold

Random erasure of base tiles from a depth-3 H-patch (442 tiles):

| Erasure % | Surviving % | Determined % |
|-----------|------------|-------------|
| 0% | 100.0% | 100.0% |
| 10% | 90.0% | 79.7% |
| 30% | 69.9% | 67.8% |
| 50% | 50.0% | 60.2% |
| 70% | 30.1% | 48.0% |
| 90% | 10.0% | 35.6% |

The "Determined %" exceeds "Surviving %" at erasure fractions above ~45% — meaning the hierarchical structure allows recovery of more tiles than survive the erasure. The phase transition to complete loss is at ~60-70% erasure.

### Dependency graph structure

The recovery dependency graph (radius 1) has 360 edges, cycles, and a bimodal in-degree distribution: 370 tiles with degree 0 (self-determined) and 72 tiles with degree 5 (dependent on all siblings). Maximum chain length is 4.

## Spectre Erasure Plateau Collapses with Depth (#23)

The spectre system's erasure resilience degrades sharply with hierarchy depth. The plateau level (determined% at mid-range erasure) falls geometrically, and the threshold location shifts toward lower erasure rates.

### Erasure sweep by depth (spectre, 100 trials)

| Erasure % | Depth 1 (8 tiles) | Depth 2 (63 tiles) | Depth 3 (496 tiles) | Depth 4 (3905 tiles) |
|-----------|------------------|-------------------|--------------------|--------------------|
| 10% | 100.0% | 73.4% | 50.1% | 46.8% |
| 20% | 100.0% | 80.7% | 38.4% | 23.2% |
| 30% | 100.0% | 84.1% | 38.2% | 10.8% |
| 40% | 100.0% | 85.0% | 39.6% | 8.5% |
| 50% | 100.0% | 87.2% | 42.6% | 7.6% |
| 60% | 100.0% | 85.6% | 44.1% | 7.2% |
| 70% | 100.0% | 86.5% | 44.2% | 6.9% |
| 80% | 100.0% | 79.2% | 38.0% | 7.4% |
| 90% | 100.0% | 73.7% | 34.5% | 8.1% |
| Phase transition | ~90-100% | ~90-100% | ~10-20% | **~0-10%** |

### Summary of structural metrics by depth

| Depth | Base tiles | Dep. edges | Edges/tile | Degree-0 % | Max chain |
|-------|-----------|-----------|-----------|-----------|-----------|
| 1 | 8 | 0 | 0.00 | 100% | 0 |
| 2 | 63 | 343 | 5.44 | 22.2% | 8 |
| 3 | 496 | 2,695 | 5.43 | 22.4% | 8 |
| 4 | 3,905 | 21,217 | 5.43 | 22.4% | 8 |

The dependency graph structure **stabilizes at depth 2**: edges-per-tile, degree-0 fraction, and max chain length are all constant from depth 2 onward. This is a fixed-point of the substitution structure.

### Two anomalies worth noting

**Depth 1 is perfectly resilient.** At depth 1 (a single Spectre'/Mystic' supertile, 8 base tiles), the dependency graph has zero edges and every tile is degree-0. All tiles stay fully determined under any partial erasure (up to 90%). The tiling is trivially recoverable because there is only one supertile and all children collectively identify it.

**Depth 2 inverts the relationship.** Determined% *exceeds* surviving% across nearly the full erasure range (e.g., 87.2% determined at 50% erasure vs 49.2% surviving). The hierarchy does real recovery work — partial context is enough to reconstruct more than survives. This is the correcting-code regime. By depth 3 the relationship inverts, and by depth 4 it collapses entirely.

### The threshold sharpens with depth

At depth 4, losing just 10% of tiles immediately reduces determined% to 46.8%; losing 20% drops it to 23.2%; from 30% onward it plateaus near 7-8%. The system is converging toward a **true threshold structure**: below a ~90% survival rate, almost nothing is determinable. This is the opposite of the error-correcting code property — it is an all-or-nothing information lock.

The plateau level progression (100% → 87% → 42% → 7.5%) is consistent with exponential decay per depth level. If the trend continues, depth 5 would yield a plateau near ~1-2%, and depth 6 near ~0%. A depth-5 or depth-6 spectre hierarchy would approach a true (k,n) threshold scheme where k ≈ 0.90n tiles are needed to determine anything at all.

## Hat-Turtle Is Identical to Hat on the Correcting/Detecting Spectrum (#22)

Hat-turtle produces identical vulnerability results to hat on every measurable metric, to the decimal place.

| Metric | Hat | Hat-Turtle |
|--------|-----|------------|
| Valid swaps | 1: P'↔F' | 1: P'↔F' |
| Critical positions | 0/22 (0%) | 0/22 (0%) |
| Min det. set H' | 1 | 1 |
| Min det. set T' | 1 | 1 |
| Min det. set P' | 5 (all) | 5 (all) |
| Min det. set F' | 6 (all) | 6 (all) |
| Erasure threshold | ~60-70% | ~60-70% |
| Dep. graph edges | 360 | 360 |
| Max chain length | 4 | 4 |
| Degree-0 tiles | 370 (83.7%) | 370 (83.7%) |
| Base tiles (depth 3) | 442 | 442 |

The erasure sweep is also identical:

| Erasure % | Hat determined | Hat-Turtle determined |
|-----------|---------------|----------------------|
| 10% | 79.7% | 79.7% |
| 30% | 67.8% | 67.8% |
| 50% | 60.2% | 60.2% |
| 70% | 48.0% | 48.0% |
| 90% | 35.6% | 35.6% |

### Interpretation

Hat and hat-turtle share the same substitution matrix — they differ only in the geometric shape of the base tile (hat vs turtle), not in the algebraic rules of how supertiles compose. The vulnerability analysis depends entirely on the substitution matrix (child type-bags, confusable pairs, dependency structure), not on tile geometry. Identical matrix → identical spectrum position.

**The correcting/detecting spectrum has only two points so far: {hat, hat-turtle} at one end and {spectre} at the other.** Hat-turtle does not give us a third data point between them — it confirms hat and hat-turtle are the same point. The spectrum is determined by substitution algebra, not tile shape. Testing additional geometric variants of the same substitution system will not move the needle.

## Spectre vs Hat Erasure Resilience (#17)

The spectre system has **worse** erasure resilience than the hat, contradicting the hypothesis that fewer tile types would yield better tolerance.

### Confusable pairs: both systems have exactly one

| Property | Hat | Spectre |
|----------|-----|---------|
| Tile types | 4 (H/T/P/F) | 2 (Spectre/Mystic) |
| Supertile types | 4 (H'/T'/P'/F') | 2 (Spectre'/Mystic') |
| Valid swaps | 1: P'(5) + 1F = F'(6) | 1: Mystic'(7) + 1Spectre = Spectre'(8) |
| Critical positions | 0/22 (0.0%) | 0/15 (0.0%) |

The hypothesis that spectre has zero confusable pairs was wrong. The sub-multiset relationship exists at the supertile level: Mystic' is a proper sub-multiset of Spectre', differing by one Spectre tile.

### Minimum determining sets

| Supertile | Children | Min det. set | Notes |
|-----------|----------|-------------|-------|
| **Hat H'** | 10 | **1** (pos 3, a T) | T only appears in H-supertiles |
| **Hat T'** | 1 | **1** (pos 0, an H) | Only 1 child total |
| Hat P' | 5 | 5 (all) | Confusable with F' |
| Hat F' | 6 | 6 (all) | Confusable with P' |
| Spectre Spectre' | 8 | **7** (all non-Mystic) | Confusable with Mystic' |
| Spectre Mystic' | 7 | **7** (all) | Confusable with Spectre' |

Hat has two "anchor" types (H', T') identifiable from a single child. Spectre has **no anchors** — both types require all children for determination.

### Erasure sweep comparison (depth 3, 100 trials)

| Erasure % | Hat surviving | Hat determined | Spectre surviving | Spectre determined |
|-----------|-------------|---------------|-------------------|-------------------|
| 0% | 100.0% | 100.0% | 100.0% | 100.0% |
| 10% | 90.0% | 79.7% | 89.9% | 50.1% |
| 20% | 80.1% | 72.9% | 80.0% | 38.4% |
| 30% | 69.9% | 67.8% | 70.0% | 38.2% |
| 40% | 60.0% | 65.2% | 60.1% | 39.6% |
| 50% | 50.0% | 60.2% | 50.0% | 42.6% |
| 60% | 40.0% | 55.2% | 39.9% | 44.1% |
| 70% | 30.1% | 48.0% | 30.0% | 44.2% |
| 80% | 19.9% | 41.9% | 20.0% | 38.0% |
| 90% | 10.0% | 35.6% | 10.1% | 34.5% |

Hat degrades gracefully, with determined% exceeding surviving% above ~45% erasure. Spectre collapses immediately: 10% erasure destroys half of all type determination. The spectre determined% then plateaus around 38-44% through the mid-range, never exceeding surviving%.

**Phase transition**: Hat at ~60-70% erasure. Spectre at ~10-20% erasure.

### Dependency graph comparison

| Metric | Hat | Spectre |
|--------|-----|---------|
| Base tiles (depth 3) | 442 | 496 |
| Total edges | 360 | 2,695 |
| Edges per tile | 0.81 | 5.43 |
| Has cycles | yes | yes |
| Max chain length | 4 | 8 |
| Max in-degree | 5 | 7 |
| Degree-0 tiles (self-determined) | 370 (83.7%) | 111 (22.4%) |
| High-degree tiles | 72 at degree 5 | 385 at degree 7 |

Hat's graph is sparse: 84% of tiles are self-determined (degree 0), with only 16% depending on siblings. Spectre's graph is dense: 78% of tiles depend on all 7 siblings, creating cascading failures under erasure.

### Why fewer types means worse resilience

The counter-intuitive result comes from three reinforcing factors:

1. **No anchor types.** Hat's 4-type system includes H' and T', which are identifiable from a single child tile. These act as fixed recovery points — even heavy erasure leaves many anchors intact. Spectre's 2-type system has no such anchors; both types are mutually confusable.

2. **Universal confusability.** In hat, only P' and F' participate in the confusable pair (2 of 4 types). In spectre, *both* types participate (2 of 2 types). Every supertile boundary is vulnerable, not just some.

3. **Dense dependency cascades.** Spectre's larger supertile size (7-8 children vs 1-10 for hat) means each tile depends on more siblings. Losing one tile affects 7 others, which affect 7 more each. Hat's bimodal structure (most tiles at degree 0) contains cascades.

The hypothesis confused *type-level diversity* with *structural resilience*. Having more types with heterogeneous compositions creates natural anchoring points. Fewer types with homogeneous compositions means every boundary is equally fragile.

## Tiling IOP Performance (#9)

Concrete measurements for the hat-tiling-based interactive oracle proof at depth 4 (3025 base tiles, 5 hierarchy levels):

| Metric | Value |
|--------|-------|
| Hierarchy build | 44 µs |
| Prove time | 1.4 ms |
| Verify time | 263 µs |
| Commitments | 5 (one per level) |
| Merkle openings | 280 (8 queries × 4 rounds × ~8.75 children) |
| Est. proof size | ~96 KB |
| Result | ACCEPTED |

The prove/verify ratio is ~5.3x, and both are sub-millisecond at this scale. The proof size is dominated by Merkle openings (280 × ~320 bytes each), not commitments.

## Spectre vs Hat IOP Soundness (#21)

The IOP crate was generalized from hat-specific (`MetatileType`) to system-generic (`usize` type indices), enabling `prove Spectre -S spectre` to run alongside hat. Results at 8 queries per round:

### Proof size and openings by depth

| Depth | System | Base tiles | Openings | Proof size | Prove | Verify |
|-------|--------|------------|----------|------------|-------|--------|
| 1 | Hat | 10 | 88 | ~30.3 KB | 17µs | 101µs |
| 1 | Spectre | 8 | 72 | ~24.8 KB | 10µs | 53µs |
| 2 | Hat | 64 | 143 | ~49.2 KB | 43µs | 140µs |
| 2 | Spectre | 63 | 143 | ~49.2 KB | 45µs | 144µs |
| 3 | Hat | 442 | 209 | ~72.0 KB | 232µs | 252µs |
| 3 | Spectre | 496 | 214 | ~73.7 KB | 264µs | 278µs |
| 4 | Hat | 3,025 | 281 | ~96.8 KB | 1.07ms | 284µs |
| 4 | Spectre | 3,905 | 284 | ~97.8 KB | 1.13ms | 266µs |

All proofs verified. Proof sizes are within 1-2% of each other at every depth.

### Average children per query

| Depth | Hat avg | Spectre avg |
|-------|---------|-------------|
| 1 | 10.0 | 8.0 |
| 2 | 7.94 | 7.94 |
| 3 | 7.71 | 7.92 |
| 4 | 7.78 | 7.88 |

At depth 1, hat always queries the H' supertile (10 children); spectre queries Spectre' (8 children). At deeper levels, hat's 4-type mix (H'=10, T'=1, P'=5, F'=6, weighted by Perron eigenvector) pulls the average below spectre's uniform 7-8.

### Structural analysis: why the soundness question was malformed

The original hypothesis was that spectre's "no anchor" structure would translate to stronger IOP soundness than hat's T'-anchored structure. This was wrong about the relevant notion of soundness.

**This IOP proves algebraic consistency of folded values, not semantic tiling validity.** The prover commits to field values at each level, and the verifier checks that committed values fold correctly under the Fiat-Shamir challenges. Soundness — the bound on cheating probability — depends on:

1. The binding property of the Merkle commitments (Blake3 collision resistance)
2. The uniformity of the folding challenges (Fiat-Shamir randomness)

Neither of these depends on tiling structure. The confusability of supertile types (P'↔F' in hat, Mystic'↔Spectre' in spectre) is irrelevant: even if type labels are ambiguous, the prover cannot change committed field values without finding Blake3 preimages.

**The T' anchor has no soundness effect in this construction.** Hat's 1-child T' type means T'-queries require only 2 hash openings (1 supertile + 1 child), while spectre queries always require 8-9 openings. This makes hat queries cheaper, but does not change the algebraic soundness bound. A cheating prover cannot exploit the cheap T' position because changing a committed T'-child value would require a hash collision.

**Where tiling structure would matter.** If the IOP were extended to prove *semantic validity* — that the committed hierarchy is actually a valid tiling (correct tile shapes, consistent adjacencies, chirality constraints) — then spectre's no-reflection constraint and anchor-free uniformity would become relevant. Spectre's geometric rigidity (no reflected tiles) means there is one fewer degree of freedom for a cheating prover to exploit when constructing a semantically plausible fake hierarchy. Hat's chirality freedom provides the prover with local choices that do not violate the algebraic folding check but do violate geometric tiling validity.

This is an open direction: building an IOP that also commits to the *geometric* placement of tiles, not just their field values, and where spectre's rigidity provides measurable soundness improvement.

## Minimum Modification Distance (#26)

The minimum number of tile moves needed to transform one valid tiling hierarchy into a different valid tiling hierarchy. Specifically: how many tile parent-attribution changes suffice to produce an alternative globally-consistent hierarchy?

### Setup

A "modification" is reassigning 1 tile from one supertile's children to another supertile's children (the tile's type is unchanged). A confusable pair (A, B) exists when B = A + 1 child of `differing_type`. Moving that 1 tile from B to A converts A→B and B→A simultaneously.

Base-tile type-change distance was also analyzed: can changing a base tile's type (e.g., H→F) produce a valid alternative hierarchy?

### Results (depth 3)

| Metric | Hat | Spectre |
|--------|-----|---------|
| Confusable pair | P' ↔ F' (differ by 1 F child) | Mystic' ↔ Spectre' (differ by 1 Spectre child) |
| P' children / F' children | 5 / 6 | — |
| Mystic' children / Spectre' children | — | 7 / 8 |
| Base-tile type-change distance | **∞** (child count determines type uniquely) | **∞** (child count determines type uniquely) |
| Parent-attribution distance | **1** | **1** |
| Cascade cost at level 1 | 0 | 0 |
| Cascade cost at level 2 | 0 | 0 |
| Sibling pair instances (level 1) | 42 | 55 |
| Sibling pair instances (level 2) | 9 | 7 |
| Total instances | 51 | 62 |

### Why base-tile type changes cannot work

Supertile types are uniquely determined by **child count**, not just composition multiset:
- P' always has exactly 5 children; F' always has exactly 6. No type change to existing children can add or remove a child.
- Mystic' always has 7 children; Spectre' always has 8. Same argument.

Therefore the base-tile type-change distance is infinite for both systems.

### Why cascade cost is always 0 for sibling swaps

Moving 1 tile of `differing_type` from B (the larger sibling) to A (the smaller sibling):
- A gains 1 child → composition matches B's old type. A is relabeled B.
- B loses 1 child → composition matches A's old type. B is relabeled A.
- The parent at the level above had (among other children) one instance of type A and one of type B. After the swap it still has one of each — just with relabeled indices. The parent's composition multiset is unchanged. **Zero cascade.**

This is a combinatorial identity: swapping two elements in a multiset preserves the multiset.

### Conclusion: hypothesis falsified

The issue hypothesized that spectre's dense cascade structure would force modification distance > 1. This is false. **Both hat and spectre have minimum modification distance 1** (1 parent-attribution change, 0 cascade cost), exploiting their respective confusable pairs.

The erasure resilience advantage measured in #17 (spectre survives more random erasures) is irrelevant for *adversarial* modifications. A coordinated adversary does not need to erase tiles; they need only identify any sibling confusable pair and move 1 tile. Both systems provide 51–62 such opportunities at depth 3.

The modification distance is determined solely by the existence of a confusable pair and the presence of sibling instances in the hierarchy — not by the dependency graph density.

## Geometric Modification Distance: Spectre Has Infinite, Hat Has 1 (#30)

The combinatorial modification distance analysis (#26) showed that both hat and spectre have parent-attribution distance = 1. Issue #29 asked whether imposing a geometric constraint changes this: the re-attributed tile must be **at the physical boundary** between the two supertiles, not just any sibling tile.

Only **boundary children** — inflation children not assigned to any supertile — can occupy shared boundaries between adjacent supertiles. The question reduces to: does any boundary child have the same type as the `differing_type` of a confusable pair?

### Results (single inflation step, no depth parameter needed)

| Metric | Hat | Spectre |
|--------|-----|---------|
| Total inflation children | 29 | 15 |
| Boundary children (unassigned) | **7** | **0** |
| Confusable pair | P' ↔ F' (differ by 1 F child) | Mystic' ↔ Spectre' (differ by 1 Spectre child) |
| F-type boundary children | **2** (child #14, child #17) | N/A |
| Spectre-type boundary children | N/A | **0** |
| Geometric modification distance | **1** | **∞** |

### How hat achieves geometric distance 1

Hat's 29 inflation children include 7 boundary tiles not owned by any supertile (H', T', P', F'). Among these 7:
- Children #14 and #17 are **F-type**.
- The confusable pair P' ↔ F' differs by exactly 1 F child.
- Therefore an adversary can re-attribute one of these F-type boundary tiles from a P'-supertile's "sphere" to an adjacent F'-supertile's "sphere" (or vice versa), converting the P' to F' and the F' to P' — at a cost of 1 boundary attribution change.

### Why spectre has infinite geometric distance

Spectre's 15 inflation children are **all assigned** to Spectre' or Mystic' supertiles — there are no boundary tiles. Without any shared boundary tile at a Mystic'–Spectre' junction, no geometric attribution change is possible. Even though the combinatorial (parent-attribution) distance is 1, it requires a tile physically *inside* one supertile, which cannot be at the boundary.

### Interpretation

The geometric constraint reveals a strict hierarchy of adversarial models:

| Model | Hat | Spectre |
|-------|-----|---------|
| Combinatorial (attribution only) | 1 | 1 |
| Geometric (boundary tiles only) | 1 | **∞** |

Spectre is **strictly more resistant** to geometrically-constrained adversaries. Hat's 7 boundary children — a structural "glue" artifact of its inflation rule — are its geometric weak point. Spectre eliminated this artifact: every inflation child is fully owned, leaving no ambiguous tile at shared boundaries.

This is a concrete separation: any adversary who must move a physically-present tile (rather than relabel an abstract child index) cannot attack spectre at cost 1. Hat remains vulnerable.

## Swap Opportunity Scaling with Depth (#29)

The number of sibling confusable-pair instances grows exponentially with hierarchy depth at a rate matching the dominant eigenvalue of the substitution matrix.

### Hat (P'↔F' pair, seed=H)

| Depth | Level 1 | Level 2 | Level 3 | Level 4 | Level 5 | Total |
|-------|---------|---------|---------|---------|---------|-------|
| 2     | 9       | —       | —       | —       | —       | 9     |
| 3     | 42      | 9       | —       | —       | —       | 51    |
| 4     | 300     | 42      | 9       | —       | —       | 351   |
| 5     | 2,037   | 300     | 42      | 9       | —       | 2,388 |
| 6     | 13,974  | 2,037   | 300     | 42      | 9       | 16,362 |

Level-1 growth ratio: 300/42 ≈ 7.14, 2037/300 ≈ 6.79, 13974/2037 ≈ **6.86** → converges to the hat dominant eigenvalue (~6.86).

### Spectre (Mystic'↔Spectre' pair, seed=Spectre)

| Depth | Level 1 | Level 2 | Level 3 | Level 4 | Level 5 | Total  |
|-------|---------|---------|---------|---------|---------|--------|
| 2     | 7       | —       | —       | —       | —       | 7      |
| 3     | 55      | 7       | —       | —       | —       | 62     |
| 4     | 433     | 55      | 7       | —       | —       | 495    |
| 5     | 3,409   | 433     | 55      | 7       | —       | 3,904  |
| 6     | 26,839  | 3,409   | 433     | 55      | 7       | 30,743 |

Level-1 growth ratio: 433/55 ≈ 7.87, 3409/433 ≈ 7.87, 26839/3409 ≈ **7.87** → converges to the spectre dominant eigenvalue (~7.87).

### Key observations

**Telescoping structure.** The count at level k for depth d equals the count at level k for any depth d' > k. The per-level sequence is fixed; deeper hierarchies simply prepend a new, larger level-1 count. This means the "opportunity surface" is determined entirely by the substitution matrix, not by the total hierarchy depth.

**Eigenvalue-rate growth.** Both systems' swap counts grow at the dominant substitution eigenvalue rate. This makes structural sense: the number of confusable sibling pairs at level k is proportional to the number of supertile pairs at level k+1, which is proportional to the dominant eigenvector component scaled by λ^(depth−k).

**Modification distance is depth-independent.** Despite swap counts growing exponentially (from 9 at depth 2 to 16,362 at depth 6 for hat), the minimum modification distance remains 1 at all depths. Increasing depth adds attack surface, never hardens it.

**Spectre has more opportunities per level than hat.** At level 1, spectre has ~55% more instances than hat at depth 3 (55 vs 42) and ~92% more at depth 4 (433 vs 300). This reflects spectre's 8-child Spectre' supertile producing more sibling-pair opportunities per parent than hat's 5/6-child P'/F'.

## Algebraic IOP Is Blind to Sibling Swaps (#31)

The tiling IOP accepts any valid hierarchy, including hierarchies produced by sibling swaps. Two distinct hierarchies H and H' — where H' is obtained by swapping a P'/F' sibling pair and reassigning one child — both produce valid, accepted proofs. The IOP cannot distinguish between them.

### Test result

`iop_accepts_sibling_swapped_hierarchy` passes: the verifier accepts fresh proofs for both the original hierarchy and the sibling-swapped version. The two hierarchies differ at level 1 (different tile type assignments), confirming the swap genuinely changes the hierarchy.

### Why the IOP cannot detect this

The IOP's soundness guarantee is: **for a given commitment, the prover cannot cheat**. It does NOT guarantee uniqueness of the committed hierarchy. The IOP verifies:
1. Merkle proofs for each queried supertile and its children
2. That child type counts match the claimed supertile composition
3. That the fold (linear combination of children by challenge) equals the committed supertile value

All three checks hold for H'. The swapped hierarchy is genuinely valid:
- H' has the same base values (level 0 unchanged)
- At level 1, A now has F'-composition children and B has P'-composition children
- Fold values at levels 1 and above are recomputed from scratch for H'
- All Merkle trees are rebuilt for H'

The prover generates a completely honest proof for H'. No check fails. **The IOP cannot enforce that a given base-level commitment corresponds to exactly one supertile labeling.**

### Implication

The IOP proves "there exists a valid hierarchy consistent with this commitment." It does not prove "this is the unique canonical hierarchy for the underlying tiling." For applications that require canonical labeling (e.g., proving a specific spatial layout, or that two parties committed to the same hierarchy), the IOP must be augmented with a uniqueness argument. The geometric modification distance finding (#30) suggests spectre is harder to attack geometrically, but the algebraic IOP remains blind to algebraic swaps for both systems.
