# Findings: Experimental Results from Monotile Exploration

Empirical results from running experiments on the hat monotile and its algebraic structure. These are things we measured, not things we read.

## Deflation Is Not a One-Way Function (#5)

The inflation/deflation asymmetry in the hat metatile substitution system does **not** constitute a computationally one-way function. Deflation is locally solvable.

### Results (hat and spectre, depth 3)

| Analysis | Hat | Spectre |
|----------|-----|---------|
| Full sibling adjacency | All tiles determined, radius ≤ 1 | All tiles determined, radius ≤ 1 |
| Inflation adjacency | All tiles determined, radius ≤ 4 | All tiles determined, radius ≤ 1 |
| Type-bag decomposition | Always unique (det(M) = -1) | Always unique (det(M) = 1) |
| Greedy deflation | 100% assignment rate | 100% assignment rate |

The asymmetry between inflation (O(n) local rule application) and deflation (recovering supertile boundaries) is **implementation convenience, not computational hardness**. A radius-1 neighborhood in the full sibling adjacency graph suffices to determine parent assignments for every tile.

The hat's inflation adjacency graph requires radius 4 because H-supertiles are disconnected in this sparser graph — some children lack intra-supertile neighbors. But this is an artifact of the graph choice, not an inherent barrier. The spectre, with its simpler 2-type system, resolves everything at radius 1 even with inflation adjacency.

## The Local-to-Global Gap Is All-or-Nothing (#6)

The gap between local indistinguishability and global rigidity in hierarchical substitution tilings closes as a **sharp phase transition**, not a gradual curve.

### Distinguishing advantage by radius (hat and spectre, depth 3)

| Radius | Hat Advantage | Spectre Advantage | Hat Normalized MI |
|--------|--------------|-------------------|-------------------|
| 0 | 0.0% | 0.0% | 0.000 |
| 1 | 0.0% | 0.0% | 0.001 |
| 2 | 1.0% | 0.0% | 0.055 |
| 3 (=depth) | **100.0%** | **100.0%** | **1.000** |

At every radius below depth, advantage is ~0%. At radius = depth, it jumps to 100% in a single step. Both hat and spectre exhibit identical transition behavior.

### Why the transition is sharp

The substitution is **recursively self-similar**: the local structure within any finite subtree is fully determined by the subtree root's type, independent of what's above it in the hierarchy. Two tiles from different seeds but with the same ancestor chain up to level k are locally indistinguishable at radius k. Only when the chain reaches the seed does the difference become visible.

The BFS-based type signature makes this even starker: with sibling adjacency, a tile can determine its immediate parent type at radius 1, but **cannot determine any higher ancestor** regardless of radius. The adjacency graph is disconnected at supertile boundaries, creating an absolute information barrier.

### Ancestry determination (hat, depth 3, seed H)

| Level | Relation | Determined | Fraction |
|-------|----------|------------|----------|
| 1 | Parent | 442/442 | 100% at radius 1 |
| 2 | Grandparent | 3/442 | 0.7% — nearly all undetermined |
| 3 | Seed | 442/442 | 100% (trivially, only one seed type) |

This demonstrates the BFS information barrier: sibling adjacency reveals parent type but nothing higher.

### Mutual information reveals partial structure

While distinguishing advantage is 0 for radii < depth, **mutual information** is nonzero starting at radius 1-2. The *distribution* of tiles across signatures varies by seed even when no individual signature is unique. A Bayesian observer gains partial information before the gap closes; a deterministic algorithm cannot.

### Connection to proximity gaps

The tiling gap is **dual** to the proximity gap in FRI/coding theory:
- **Proximity gap**: globally invalid → locally detectable (local tests are powerful)
- **Tiling gap**: globally different → locally undetectable until threshold (local observations are weak)

Both exhibit sharp transitions. The proximity gap makes the IOP verifier efficient; the tiling gap characterizes the cost of identification.

### Implications

The gap is **not suitable as a smooth hardness assumption** like LWE. It's a binary property: either you can see the seed (trivially easy) or you can't (information-theoretically impossible). More like a one-time pad than a lattice problem — unconditional but non-tunable.

For the IOP construction, this is ideal: the hierarchical commitment is unconditionally binding within any finite radius, and efficiency comes from the proximity gap on the proof side.

## Group Cryptography on Gamma = Z² ⋊ D₆ Is Not Viable (#8)

We tested three candidate hard problems for the Cucaracha's Coxeter group Gamma, motivated by the question of whether the tiling constraint could inject hardness into an otherwise tractable group.

### Cotiler Recovery

Given the cotiler group G_C (generated by pairwise quotients of tile positions), recover the cotiler C (up to translation).

| Size | Brute-force time | Solutions | Notes |
|------|-----------------|-----------|-------|
| 1 | 0.00 ms | 1 | Trivial |
| 2 | ~0.2 ms | 1-2 | Fast |
| 3 | ~3 ms | 3 | Fast |
| 4 | ~50 ms | 2-4 | Manageable |
| 5 | ~6,000 ms | 1-5 | Exponential blowup begins |
| 6 | >31,000 ms | budget exceeded (10M nodes) | Combinatorial explosion |

The bottleneck is C(candidates, n-1) where candidates grow as ~n²×4. At size 6, the candidate pool reaches ~136 elements, giving C(136, 5) ≈ 500M subsets to check.

**Coset decomposition doesn't help.** We implemented a coset-based algorithm that groups candidates by their Z² translation component and backtracks over translation classes (at most 12 D₆ decorations each). Result: ~1.0x speedup across all sizes. The translation classes are too numerous — there are roughly as many classes as individual candidates, so the grouping provides no reduction.

### Region Decomposition (Exact Cover)

Given the covered cells (forgetting tile boundaries), recover which tiles placed them.

| Size | Mean time | Solutions | Notes |
|------|-----------|-----------|-------|
| 1-20 | 0.00-0.07 ms | always exactly 1 | Linear scaling |

Trivially easy at all tested sizes. The Cucaracha's shape is sufficiently constrained that backtracking with a most-constrained-cell heuristic finds the unique decomposition almost immediately.

### Stabilizer Statistics

Compute the symmetry group of a random cotiler.

| Size | Trials | Trivial (|Stab|=1) | Threefold (|Stab|=3) |
|------|--------|-------------------|---------------------|
| 1-20 | 10 each | 100% | 0% |

All 200 random cotilers tested had trivial stabilizer. The threefold symmetry (rotation by 120°) that is theoretically possible never appeared in random growth.

### Verdict

All three problems are easy or show only brute-force combinatorial hardness (not algebraic hardness). The virtually abelian structure of Gamma = Z² ⋊ D₆ makes group-theoretic hard problems (word problem, conjugacy problem) trivially solvable. The tiling constraint adds a geometric overlap check but does not create cryptographically useful hardness — it's an NP-style constraint satisfaction problem, not a one-way function.

The recovery scaling is exponential in cotiler size, but this is a consequence of naive subset enumeration over a polynomially-growing candidate pool, not of any deep algebraic structure. The coset comparison confirms this: exploiting the group's Z² ⋊ D₆ decomposition provides zero speedup because the hardness was never group-theoretic to begin with.

## Erasure Resilience and the P'↔F' Vulnerability

The hat tiling's recoverability has a specific structural weakness and a graceful degradation profile under random erasure.

### The only confusable pair: P' and F'

Of all four supertile types, only one valid single-tile swap exists: P' (5 children) + 1 F-tile = F' (6 children). Their child type-bags differ by exactly one F-tile, so a P-supertile can be misidentified as an F-supertile if its boundary F-tile is present.

Despite this, **zero child positions are critical** — every position in every supertile type is individually redundant. The minimum determining sets are:

| Supertile | Children | Min determining set | Key |
|-----------|----------|-------------------|-----|
| H' | 10 | 1 tile (pos 3, a T) | T only appears in H-supertiles |
| T' | 1 | 1 tile (pos 0, an H) | Only 1 child total |
| P' | 5 | All 5 | Confusable with F' |
| F' | 6 | All 6 | Confusable with P' |

### Erasure threshold

Random erasure of base tiles from a depth-3 H-patch (442 tiles):

| Erasure % | Surviving % | Determined % |
|-----------|------------|-------------|
| 0% | 100.0% | 100.0% |
| 10% | 90.0% | 79.7% |
| 30% | 69.9% | 67.8% |
| 50% | 50.0% | 60.2% |
| 70% | 30.1% | 48.0% |
| 90% | 10.0% | 35.6% |

The "Determined %" exceeds "Surviving %" at erasure fractions above ~45% — meaning the hierarchical structure allows recovery of more tiles than survive the erasure. The phase transition to complete loss is at ~60-70% erasure.

### Dependency graph structure

The recovery dependency graph (radius 1) has 360 edges, cycles, and a bimodal in-degree distribution: 370 tiles with degree 0 (self-determined) and 72 tiles with degree 5 (dependent on all siblings). Maximum chain length is 4.

## Spectre Erasure Plateau Collapses with Depth (#23)

The spectre system's erasure resilience degrades sharply with hierarchy depth. The plateau level (determined% at mid-range erasure) falls geometrically, and the threshold location shifts toward lower erasure rates.

### Erasure sweep by depth (spectre, 100 trials)

| Erasure % | Depth 1 (8 tiles) | Depth 2 (63 tiles) | Depth 3 (496 tiles) | Depth 4 (3905 tiles) |
|-----------|------------------|-------------------|--------------------|--------------------|
| 10% | 100.0% | 73.4% | 50.1% | 46.8% |
| 20% | 100.0% | 80.7% | 38.4% | 23.2% |
| 30% | 100.0% | 84.1% | 38.2% | 10.8% |
| 40% | 100.0% | 85.0% | 39.6% | 8.5% |
| 50% | 100.0% | 87.2% | 42.6% | 7.6% |
| 60% | 100.0% | 85.6% | 44.1% | 7.2% |
| 70% | 100.0% | 86.5% | 44.2% | 6.9% |
| 80% | 100.0% | 79.2% | 38.0% | 7.4% |
| 90% | 100.0% | 73.7% | 34.5% | 8.1% |
| Phase transition | ~90-100% | ~90-100% | ~10-20% | **~0-10%** |

### Summary of structural metrics by depth

| Depth | Base tiles | Dep. edges | Edges/tile | Degree-0 % | Max chain |
|-------|-----------|-----------|-----------|-----------|-----------|
| 1 | 8 | 0 | 0.00 | 100% | 0 |
| 2 | 63 | 343 | 5.44 | 22.2% | 8 |
| 3 | 496 | 2,695 | 5.43 | 22.4% | 8 |
| 4 | 3,905 | 21,217 | 5.43 | 22.4% | 8 |

The dependency graph structure **stabilizes at depth 2**: edges-per-tile, degree-0 fraction, and max chain length are all constant from depth 2 onward. This is a fixed-point of the substitution structure.

### Two anomalies worth noting

**Depth 1 is perfectly resilient.** At depth 1 (a single Spectre'/Mystic' supertile, 8 base tiles), the dependency graph has zero edges and every tile is degree-0. All tiles stay fully determined under any partial erasure (up to 90%). The tiling is trivially recoverable because there is only one supertile and all children collectively identify it.

**Depth 2 inverts the relationship.** Determined% *exceeds* surviving% across nearly the full erasure range (e.g., 87.2% determined at 50% erasure vs 49.2% surviving). The hierarchy does real recovery work — partial context is enough to reconstruct more than survives. This is the correcting-code regime. By depth 3 the relationship inverts, and by depth 4 it collapses entirely.

### The threshold sharpens with depth

At depth 4, losing just 10% of tiles immediately reduces determined% to 46.8%; losing 20% drops it to 23.2%; from 30% onward it plateaus near 7-8%. The system is converging toward a **true threshold structure**: below a ~90% survival rate, almost nothing is determinable. This is the opposite of the error-correcting code property — it is an all-or-nothing information lock.

The plateau level progression (100% → 87% → 42% → 7.5%) is consistent with exponential decay per depth level. If the trend continues, depth 5 would yield a plateau near ~1-2%, and depth 6 near ~0%. A depth-5 or depth-6 spectre hierarchy would approach a true (k,n) threshold scheme where k ≈ 0.90n tiles are needed to determine anything at all.

## Hat-Turtle Is Identical to Hat on the Correcting/Detecting Spectrum (#22)

Hat-turtle produces identical vulnerability results to hat on every measurable metric, to the decimal place.

| Metric | Hat | Hat-Turtle |
|--------|-----|------------|
| Valid swaps | 1: P'↔F' | 1: P'↔F' |
| Critical positions | 0/22 (0%) | 0/22 (0%) |
| Min det. set H' | 1 | 1 |
| Min det. set T' | 1 | 1 |
| Min det. set P' | 5 (all) | 5 (all) |
| Min det. set F' | 6 (all) | 6 (all) |
| Erasure threshold | ~60-70% | ~60-70% |
| Dep. graph edges | 360 | 360 |
| Max chain length | 4 | 4 |
| Degree-0 tiles | 370 (83.7%) | 370 (83.7%) |
| Base tiles (depth 3) | 442 | 442 |

The erasure sweep is also identical:

| Erasure % | Hat determined | Hat-Turtle determined |
|-----------|---------------|----------------------|
| 10% | 79.7% | 79.7% |
| 30% | 67.8% | 67.8% |
| 50% | 60.2% | 60.2% |
| 70% | 48.0% | 48.0% |
| 90% | 35.6% | 35.6% |

### Interpretation

Hat and hat-turtle share the same substitution matrix — they differ only in the geometric shape of the base tile (hat vs turtle), not in the algebraic rules of how supertiles compose. The vulnerability analysis depends entirely on the substitution matrix (child type-bags, confusable pairs, dependency structure), not on tile geometry. Identical matrix → identical spectrum position.

**The correcting/detecting spectrum has only two points so far: {hat, hat-turtle} at one end and {spectre} at the other.** Hat-turtle does not give us a third data point between them — it confirms hat and hat-turtle are the same point. The spectrum is determined by substitution algebra, not tile shape. Testing additional geometric variants of the same substitution system will not move the needle.

## Spectre vs Hat Erasure Resilience (#17)

The spectre system has **worse** erasure resilience than the hat, contradicting the hypothesis that fewer tile types would yield better tolerance.

### Confusable pairs: both systems have exactly one

| Property | Hat | Spectre |
|----------|-----|---------|
| Tile types | 4 (H/T/P/F) | 2 (Spectre/Mystic) |
| Supertile types | 4 (H'/T'/P'/F') | 2 (Spectre'/Mystic') |
| Valid swaps | 1: P'(5) + 1F = F'(6) | 1: Mystic'(7) + 1Spectre = Spectre'(8) |
| Critical positions | 0/22 (0.0%) | 0/15 (0.0%) |

The hypothesis that spectre has zero confusable pairs was wrong. The sub-multiset relationship exists at the supertile level: Mystic' is a proper sub-multiset of Spectre', differing by one Spectre tile.

### Minimum determining sets

| Supertile | Children | Min det. set | Notes |
|-----------|----------|-------------|-------|
| **Hat H'** | 10 | **1** (pos 3, a T) | T only appears in H-supertiles |
| **Hat T'** | 1 | **1** (pos 0, an H) | Only 1 child total |
| Hat P' | 5 | 5 (all) | Confusable with F' |
| Hat F' | 6 | 6 (all) | Confusable with P' |
| Spectre Spectre' | 8 | **7** (all non-Mystic) | Confusable with Mystic' |
| Spectre Mystic' | 7 | **7** (all) | Confusable with Spectre' |

Hat has two "anchor" types (H', T') identifiable from a single child. Spectre has **no anchors** — both types require all children for determination.

### Erasure sweep comparison (depth 3, 100 trials)

| Erasure % | Hat surviving | Hat determined | Spectre surviving | Spectre determined |
|-----------|-------------|---------------|-------------------|-------------------|
| 0% | 100.0% | 100.0% | 100.0% | 100.0% |
| 10% | 90.0% | 79.7% | 89.9% | 50.1% |
| 20% | 80.1% | 72.9% | 80.0% | 38.4% |
| 30% | 69.9% | 67.8% | 70.0% | 38.2% |
| 40% | 60.0% | 65.2% | 60.1% | 39.6% |
| 50% | 50.0% | 60.2% | 50.0% | 42.6% |
| 60% | 40.0% | 55.2% | 39.9% | 44.1% |
| 70% | 30.1% | 48.0% | 30.0% | 44.2% |
| 80% | 19.9% | 41.9% | 20.0% | 38.0% |
| 90% | 10.0% | 35.6% | 10.1% | 34.5% |

Hat degrades gracefully, with determined% exceeding surviving% above ~45% erasure. Spectre collapses immediately: 10% erasure destroys half of all type determination. The spectre determined% then plateaus around 38-44% through the mid-range, never exceeding surviving%.

**Phase transition**: Hat at ~60-70% erasure. Spectre at ~10-20% erasure.

### Dependency graph comparison

| Metric | Hat | Spectre |
|--------|-----|---------|
| Base tiles (depth 3) | 442 | 496 |
| Total edges | 360 | 2,695 |
| Edges per tile | 0.81 | 5.43 |
| Has cycles | yes | yes |
| Max chain length | 4 | 8 |
| Max in-degree | 5 | 7 |
| Degree-0 tiles (self-determined) | 370 (83.7%) | 111 (22.4%) |
| High-degree tiles | 72 at degree 5 | 385 at degree 7 |

Hat's graph is sparse: 84% of tiles are self-determined (degree 0), with only 16% depending on siblings. Spectre's graph is dense: 78% of tiles depend on all 7 siblings, creating cascading failures under erasure.

### Why fewer types means worse resilience

The counter-intuitive result comes from three reinforcing factors:

1. **No anchor types.** Hat's 4-type system includes H' and T', which are identifiable from a single child tile. These act as fixed recovery points — even heavy erasure leaves many anchors intact. Spectre's 2-type system has no such anchors; both types are mutually confusable.

2. **Universal confusability.** In hat, only P' and F' participate in the confusable pair (2 of 4 types). In spectre, *both* types participate (2 of 2 types). Every supertile boundary is vulnerable, not just some.

3. **Dense dependency cascades.** Spectre's larger supertile size (7-8 children vs 1-10 for hat) means each tile depends on more siblings. Losing one tile affects 7 others, which affect 7 more each. Hat's bimodal structure (most tiles at degree 0) contains cascades.

The hypothesis confused *type-level diversity* with *structural resilience*. Having more types with heterogeneous compositions creates natural anchoring points. Fewer types with homogeneous compositions means every boundary is equally fragile.

## Tiling IOP Performance (#9)

Concrete measurements for the hat-tiling-based interactive oracle proof at depth 4 (3025 base tiles, 5 hierarchy levels):

| Metric | Value |
|--------|-------|
| Hierarchy build | 44 µs |
| Prove time | 1.4 ms |
| Verify time | 263 µs |
| Commitments | 5 (one per level) |
| Merkle openings | 280 (8 queries × 4 rounds × ~8.75 children) |
| Est. proof size | ~96 KB |
| Result | ACCEPTED |

The prove/verify ratio is ~5.3x, and both are sub-millisecond at this scale. The proof size is dominated by Merkle openings (280 × ~320 bytes each), not commitments.

## Spectre vs Hat IOP Soundness (#21)

The IOP crate was generalized from hat-specific (`MetatileType`) to system-generic (`usize` type indices), enabling `prove Spectre -S spectre` to run alongside hat. Results at 8 queries per round:

### Proof size and openings by depth

| Depth | System | Base tiles | Openings | Proof size | Prove | Verify |
|-------|--------|------------|----------|------------|-------|--------|
| 1 | Hat | 10 | 88 | ~30.3 KB | 17µs | 101µs |
| 1 | Spectre | 8 | 72 | ~24.8 KB | 10µs | 53µs |
| 2 | Hat | 64 | 143 | ~49.2 KB | 43µs | 140µs |
| 2 | Spectre | 63 | 143 | ~49.2 KB | 45µs | 144µs |
| 3 | Hat | 442 | 209 | ~72.0 KB | 232µs | 252µs |
| 3 | Spectre | 496 | 214 | ~73.7 KB | 264µs | 278µs |
| 4 | Hat | 3,025 | 281 | ~96.8 KB | 1.07ms | 284µs |
| 4 | Spectre | 3,905 | 284 | ~97.8 KB | 1.13ms | 266µs |

All proofs verified. Proof sizes are within 1-2% of each other at every depth.

### Average children per query

| Depth | Hat avg | Spectre avg |
|-------|---------|-------------|
| 1 | 10.0 | 8.0 |
| 2 | 7.94 | 7.94 |
| 3 | 7.71 | 7.92 |
| 4 | 7.78 | 7.88 |

At depth 1, hat always queries the H' supertile (10 children); spectre queries Spectre' (8 children). At deeper levels, hat's 4-type mix (H'=10, T'=1, P'=5, F'=6, weighted by Perron eigenvector) pulls the average below spectre's uniform 7-8.

### Structural analysis: why the soundness question was malformed

The original hypothesis was that spectre's "no anchor" structure would translate to stronger IOP soundness than hat's T'-anchored structure. This was wrong about the relevant notion of soundness.

**This IOP proves algebraic consistency of folded values, not semantic tiling validity.** The prover commits to field values at each level, and the verifier checks that committed values fold correctly under the Fiat-Shamir challenges. Soundness — the bound on cheating probability — depends on:

1. The binding property of the Merkle commitments (Blake3 collision resistance)
2. The uniformity of the folding challenges (Fiat-Shamir randomness)

Neither of these depends on tiling structure. The confusability of supertile types (P'↔F' in hat, Mystic'↔Spectre' in spectre) is irrelevant: even if type labels are ambiguous, the prover cannot change committed field values without finding Blake3 preimages.

**The T' anchor has no soundness effect in this construction.** Hat's 1-child T' type means T'-queries require only 2 hash openings (1 supertile + 1 child), while spectre queries always require 8-9 openings. This makes hat queries cheaper, but does not change the algebraic soundness bound. A cheating prover cannot exploit the cheap T' position because changing a committed T'-child value would require a hash collision.

**Where tiling structure would matter.** If the IOP were extended to prove *semantic validity* — that the committed hierarchy is actually a valid tiling (correct tile shapes, consistent adjacencies, chirality constraints) — then spectre's no-reflection constraint and anchor-free uniformity would become relevant. Spectre's geometric rigidity (no reflected tiles) means there is one fewer degree of freedom for a cheating prover to exploit when constructing a semantically plausible fake hierarchy. Hat's chirality freedom provides the prover with local choices that do not violate the algebraic folding check but do violate geometric tiling validity.

This is an open direction: building an IOP that also commits to the *geometric* placement of tiles, not just their field values, and where spectre's rigidity provides measurable soundness improvement.

## Minimum Modification Distance (#26)

The minimum number of tile moves needed to transform one valid tiling hierarchy into a different valid tiling hierarchy. Specifically: how many tile parent-attribution changes suffice to produce an alternative globally-consistent hierarchy?

### Setup

A "modification" is reassigning 1 tile from one supertile's children to another supertile's children (the tile's type is unchanged). A confusable pair (A, B) exists when B = A + 1 child of `differing_type`. Moving that 1 tile from B to A converts A→B and B→A simultaneously.

Base-tile type-change distance was also analyzed: can changing a base tile's type (e.g., H→F) produce a valid alternative hierarchy?

### Results (depth 3)

| Metric | Hat | Spectre |
|--------|-----|---------|
| Confusable pair | P' ↔ F' (differ by 1 F child) | Mystic' ↔ Spectre' (differ by 1 Spectre child) |
| P' children / F' children | 5 / 6 | — |
| Mystic' children / Spectre' children | — | 7 / 8 |
| Base-tile type-change distance | **∞** (child count determines type uniquely) | **∞** (child count determines type uniquely) |
| Parent-attribution distance | **1** | **1** |
| Cascade cost at level 1 | 0 | 0 |
| Cascade cost at level 2 | 0 | 0 |
| Sibling pair instances (level 1) | 42 | 55 |
| Sibling pair instances (level 2) | 9 | 7 |
| Total instances | 51 | 62 |

### Why base-tile type changes cannot work

Supertile types are uniquely determined by **child count**, not just composition multiset:
- P' always has exactly 5 children; F' always has exactly 6. No type change to existing children can add or remove a child.
- Mystic' always has 7 children; Spectre' always has 8. Same argument.

Therefore the base-tile type-change distance is infinite for both systems.

### Why cascade cost is always 0 for sibling swaps

Moving 1 tile of `differing_type` from B (the larger sibling) to A (the smaller sibling):
- A gains 1 child → composition matches B's old type. A is relabeled B.
- B loses 1 child → composition matches A's old type. B is relabeled A.
- The parent at the level above had (among other children) one instance of type A and one of type B. After the swap it still has one of each — just with relabeled indices. The parent's composition multiset is unchanged. **Zero cascade.**

This is a combinatorial identity: swapping two elements in a multiset preserves the multiset.

### Conclusion: hypothesis falsified

The issue hypothesized that spectre's dense cascade structure would force modification distance > 1. This is false. **Both hat and spectre have minimum modification distance 1** (1 parent-attribution change, 0 cascade cost), exploiting their respective confusable pairs.

The erasure resilience advantage measured in #17 (spectre survives more random erasures) is irrelevant for *adversarial* modifications. A coordinated adversary does not need to erase tiles; they need only identify any sibling confusable pair and move 1 tile. Both systems provide 51–62 such opportunities at depth 3.

The modification distance is determined solely by the existence of a confusable pair and the presence of sibling instances in the hierarchy — not by the dependency graph density.

## Geometric Modification Distance: Spectre Has Infinite, Hat Has 1 (#30)

The combinatorial modification distance analysis (#26) showed that both hat and spectre have parent-attribution distance = 1. Issue #29 asked whether imposing a geometric constraint changes this: the re-attributed tile must be **at the physical boundary** between the two supertiles, not just any sibling tile.

Only **boundary children** — inflation children not assigned to any supertile — can occupy shared boundaries between adjacent supertiles. The question reduces to: does any boundary child have the same type as the `differing_type` of a confusable pair?

### Results (single inflation step, no depth parameter needed)

| Metric | Hat | Spectre |
|--------|-----|---------|
| Total inflation children | 29 | 15 |
| Boundary children (unassigned) | **7** | **0** |
| Confusable pair | P' ↔ F' (differ by 1 F child) | Mystic' ↔ Spectre' (differ by 1 Spectre child) |
| F-type boundary children | **2** (child #14, child #17) | N/A |
| Spectre-type boundary children | N/A | **0** |
| Geometric modification distance | **1** | **∞** |

### How hat achieves geometric distance 1

Hat's 29 inflation children include 7 boundary tiles not owned by any supertile (H', T', P', F'). Among these 7:
- Children #14 and #17 are **F-type**.
- The confusable pair P' ↔ F' differs by exactly 1 F child.
- Therefore an adversary can re-attribute one of these F-type boundary tiles from a P'-supertile's "sphere" to an adjacent F'-supertile's "sphere" (or vice versa), converting the P' to F' and the F' to P' — at a cost of 1 boundary attribution change.

### Why spectre has infinite geometric distance

Spectre's 15 inflation children are **all assigned** to Spectre' or Mystic' supertiles — there are no boundary tiles. Without any shared boundary tile at a Mystic'–Spectre' junction, no geometric attribution change is possible. Even though the combinatorial (parent-attribution) distance is 1, it requires a tile physically *inside* one supertile, which cannot be at the boundary.

### Interpretation

The geometric constraint reveals a strict hierarchy of adversarial models:

| Model | Hat | Spectre |
|-------|-----|---------|
| Combinatorial (attribution only) | 1 | 1 |
| Geometric (boundary tiles only) | 1 | **∞** |

Spectre is **strictly more resistant** to geometrically-constrained adversaries. Hat's 7 boundary children — a structural "glue" artifact of its inflation rule — are its geometric weak point. Spectre eliminated this artifact: every inflation child is fully owned, leaving no ambiguous tile at shared boundaries.

This is a concrete separation: any adversary who must move a physically-present tile (rather than relabel an abstract child index) cannot attack spectre at cost 1. Hat remains vulnerable.

## Swap Opportunity Scaling with Depth (#29)

The number of sibling confusable-pair instances grows exponentially with hierarchy depth at a rate matching the dominant eigenvalue of the substitution matrix.

### Hat (P'↔F' pair, seed=H)

| Depth | Level 1 | Level 2 | Level 3 | Level 4 | Level 5 | Total |
|-------|---------|---------|---------|---------|---------|-------|
| 2     | 9       | —       | —       | —       | —       | 9     |
| 3     | 42      | 9       | —       | —       | —       | 51    |
| 4     | 300     | 42      | 9       | —       | —       | 351   |
| 5     | 2,037   | 300     | 42      | 9       | —       | 2,388 |
| 6     | 13,974  | 2,037   | 300     | 42      | 9       | 16,362 |

Level-1 growth ratio: 300/42 ≈ 7.14, 2037/300 ≈ 6.79, 13974/2037 ≈ **6.86** → converges to the hat dominant eigenvalue (~6.86).

### Spectre (Mystic'↔Spectre' pair, seed=Spectre)

| Depth | Level 1 | Level 2 | Level 3 | Level 4 | Level 5 | Total  |
|-------|---------|---------|---------|---------|---------|--------|
| 2     | 7       | —       | —       | —       | —       | 7      |
| 3     | 55      | 7       | —       | —       | —       | 62     |
| 4     | 433     | 55      | 7       | —       | —       | 495    |
| 5     | 3,409   | 433     | 55      | 7       | —       | 3,904  |
| 6     | 26,839  | 3,409   | 433     | 55      | 7       | 30,743 |

Level-1 growth ratio: 433/55 ≈ 7.87, 3409/433 ≈ 7.87, 26839/3409 ≈ **7.87** → converges to the spectre dominant eigenvalue (~7.87).

### Key observations

**Telescoping structure.** The count at level k for depth d equals the count at level k for any depth d' > k. The per-level sequence is fixed; deeper hierarchies simply prepend a new, larger level-1 count. This means the "opportunity surface" is determined entirely by the substitution matrix, not by the total hierarchy depth.

**Eigenvalue-rate growth.** Both systems' swap counts grow at the dominant substitution eigenvalue rate. This makes structural sense: the number of confusable sibling pairs at level k is proportional to the number of supertile pairs at level k+1, which is proportional to the dominant eigenvector component scaled by λ^(depth−k).

**Modification distance is depth-independent.** Despite swap counts growing exponentially (from 9 at depth 2 to 16,362 at depth 6 for hat), the minimum modification distance remains 1 at all depths. Increasing depth adds attack surface, never hardens it.

**Spectre has more opportunities per level than hat.** At level 1, spectre has ~55% more instances than hat at depth 3 (55 vs 42) and ~92% more at depth 4 (433 vs 300). This reflects spectre's 8-child Spectre' supertile producing more sibling-pair opportunities per parent than hat's 5/6-child P'/F'.

## Algebraic IOP Is Blind to Sibling Swaps (#31)

The tiling IOP accepts any valid hierarchy, including hierarchies produced by sibling swaps. Two distinct hierarchies H and H' — where H' is obtained by swapping a P'/F' sibling pair and reassigning one child — both produce valid, accepted proofs. The IOP cannot distinguish between them.

### Test result

`iop_accepts_sibling_swapped_hierarchy` passes: the verifier accepts fresh proofs for both the original hierarchy and the sibling-swapped version. The two hierarchies differ at level 1 (different tile type assignments), confirming the swap genuinely changes the hierarchy.

### Why the IOP cannot detect this

The IOP's soundness guarantee is: **for a given commitment, the prover cannot cheat**. It does NOT guarantee uniqueness of the committed hierarchy. The IOP verifies:
1. Merkle proofs for each queried supertile and its children
2. That child type counts match the claimed supertile composition
3. That the fold (linear combination of children by challenge) equals the committed supertile value

All three checks hold for H'. The swapped hierarchy is genuinely valid:
- H' has the same base values (level 0 unchanged)
- At level 1, A now has F'-composition children and B has P'-composition children
- Fold values at levels 1 and above are recomputed from scratch for H'
- All Merkle trees are rebuilt for H'

The prover generates a completely honest proof for H'. No check fails. **The IOP cannot enforce that a given base-level commitment corresponds to exactly one supertile labeling.**

### Implication

The IOP proves "there exists a valid hierarchy consistent with this commitment." It does not prove "this is the unique canonical hierarchy for the underlying tiling." For applications that require canonical labeling (e.g., proving a specific spatial layout, or that two parties committed to the same hierarchy), the IOP must be augmented with a uniqueness argument. The geometric modification distance finding (#30) suggests spectre is harder to attack geometrically, but the algebraic IOP remains blind to algebraic swaps for both systems.

## Swap Density Convergence (#36)

The fraction of sibling pairs that are confusable (swap density) is a structural constant determined by the substitution rules — for hat it is exactly constant at all depths; for spectre it converges to a value determined by the dominant eigenvector.

### Hat: exactly 1/5 at every level and every depth

For each supertile type in hat, the ratio (swap pairs from this parent) / (total sibling pairs from this parent) is:

| Parent type | Children (n) | P'×F' swap pairs | Total pairs C(n,2) | Density |
|-------------|-------------|-------------------|---------------------|---------|
| H' | 10 | 3×3 = 9 | 45 | **1/5** |
| T' | 1 | 0 | 0 | — |
| P' | 5 | 1×2 = 2 | 10 | **1/5** |
| F' | 6 | 1×3 = 3 | 15 | **1/5** |

Every non-trivial supertile type contributes exactly 20% swap-vulnerable pairs. Since the density is identical for all contributing types, the overall density is exactly 1/5 regardless of the mix of parent types at any level. This holds at **every level and every depth** — it is depth-independent and purely a function of the substitution rules.

Verified computationally: all levels at all depths 2–6 give exactly 0.2000.

### Spectre: converges to ~25.37%

Spectre's two types have different local densities:

| Parent type | Children (n) | S×M swap pairs | Total pairs | Density |
|-------------|-------------|----------------|-------------|---------|
| Spectre' | 8 | 7×1 = 7 | 28 | 25.00% |
| Mystic' | 7 | 6×1 = 6 | 21 | 28.57% |

The overall density at each level depends on the S':M' ratio at the level above. This ratio converges to the dominant eigenvector ratio (3+2√3):1 ≈ 6.464:1, giving asymptotic density:

**f* = (6.464×7 + 6) / (6.464×28 + 21) = 51.25/202.0 ≈ 25.37%**

Observed convergence: depth-2 level-1 = 25.00%, depth-3 level-1 = 25.35%, depth-4+ level-1 = 25.35% (converged to 4 decimal places).

### Implication

Neither system's swap density decreases with depth. Hat is locked at exactly 20%; spectre converges immediately to ~25.4%. Increasing depth does not reduce the fraction of sibling pairs that are confusable. The defense against sibling swaps must be structural (canonicalization, issue #33), not parametric.

## IOP Query Coverage of Swap-Vulnerable Positions (#34)

A "swap-vulnerable" tile is one of P'- or F'-type (hat) or Spectre'/Mystic'-type (spectre) that has at least one confusable sibling. The probability that a random IOP query hits such a tile determines how often the verifier "sees" a swap if one occurred.

### Hat: ~61.8% of tiles are swap-vulnerable

In the hat system, every P'- and F'-type tile has at least one confusable sibling (because every parent type that produces P' children also produces F' children, and vice versa). Only H'-type children of T'-type supertiles are non-vulnerable — but T' has only one H'-type child and no P'/F' children. So the vulnerable fraction equals the P'+F' fraction of all tiles.

| Depth | Level | Total tiles | Vulnerable | Fraction | Queries for 99% |
|-------|-------|-------------|------------|----------|-----------------|
| 3 | 1 | 64 | 39 | 60.9% | **5** |
| 3 | 2 | 10 | 6 | 60.0% | **5** |
| 4 | 1 | 442 | 273 | 61.8% | **5** |
| 5 | 1 | 3025 | 1869 | 61.8% | **5** |
| 6 | 1 | 20737 | 12816 | 61.8% | **5** |

Converges to ~61.8% (the P'+F' fraction of the dominant eigenvector). **5 queries per level give >99% probability of hitting a swap-vulnerable tile.**

### Spectre: 100% of tiles are swap-vulnerable

Every Spectre'- and Mystic'-type tile has at least one sibling of the opposite type, because both Spectre' (7S+1M) and Mystic' (6S+1M) parents produce at least one child of each type. **Every query hits a swap-vulnerable tile.** A single query per level gives 100% coverage.

### The IOP query count is already more than sufficient for coverage

With 8 queries per level (the default), the probability of missing ALL swap-vulnerable tiles across all levels of a depth-3 hierarchy is < 10⁻⁶. The IOP's existing query budget vastly exceeds what is needed to "see" the swapped positions. The problem is not query coverage — it is that seeing the swapped tile does not help, because the verifier accepts both hierarchies as valid. Coverage is necessary but not sufficient; a canonical form check is also needed.

## Non-Sibling Modification Cost Landscape (#35)

Are sibling swaps the unique cost-1 modifications? Yes. The modification distance landscape is bimodal: cost 1 for sibling swaps, cost ≥ 2 for everything else.

### Proof that non-sibling modifications cost ≥ 2

A cost-1 modification moves one tile from supertile A to supertile B. Two cases:

**Case 1: A and B are siblings (same parent P).**
- A loses one child of `differing_type` → A's composition changes to B's old composition → A is relabeled B.
- B gains one child → B is relabeled A.
- P's child-type multiset: had one A and one B, now has one B and one A → **unchanged**. Cascade cost = 0. Total cost = 1.
- This is the sibling swap. Valid when A and B form a confusable pair.

**Case 2: A and B are not siblings (different parents P_A and P_B).**
- A's type changes (it lost a child) → P_A's child-type multiset changes (one fewer of A's old type, one more of A's new type) → P_A's composition changes → P_A's type may change → cascade cost ≥ 1. Total cost ≥ 2.

Therefore, the only cost-1 zero-cascade modifications are sibling swaps between confusable pairs. All other modifications cost at least 2.

### Implications for the modification distance spectrum

| Modification type | Min cost | Min cascade | Example |
|-------------------|----------|-------------|---------|
| Sibling swap (confusable pair) | **1** | **0** | P'↔F' swap between siblings |
| Two independent sibling swaps | **2** | **0** | Two separate P'↔F' pairs swapped |
| Non-sibling type move | **2** | **≥1** | Move tile between non-adjacent supertiles |
| Root modification | **≥depth** | **depth** | Change the seed type propagates all the way down |

The landscape is gapped: there is no modification with cost strictly between 1 and 2. The set of reachable valid hierarchies from any given H is partitioned into: H itself (cost 0), and hierarchies at distance 1 (all sibling-swap variants, exponentially many of them), with a gap before any distance-2 modifications.

## IOP Canonical Form Defense: Zero-Cost Enforcement (#33)

The IOP verifier can be upgraded to enforce canonical hierarchy labeling at zero extra proof size and O(children_per_query) extra verification cost.

### Canonical form definition

**Inflation-order canonical**: each child's type at every parent-child edge must match the type the inflation rule specifies for that *position* in the parent's child list.

```
children[i].child_type == inflation_child_type(supertile_children(parent_type)[i])
```

The standard top-down inflation hierarchy satisfies this by construction. Any sibling swap violates it: the child at a P'-slot now has F'-type (or vice versa).

### Inflation sequences (both systems, confirmed deterministic)

**Hat (all 4 types have deterministic sequences):**

| Parent | Children sequence |
|--------|------------------|
| H' (10 children) | H, H, H, T, P, F, P, F, P, F |
| T' (1 child) | H |
| P' (5 children) | F, H, P, H, F |
| F' (6 children) | F, H, P, H, F, F |

**Spectre (both types have deterministic sequences):**

| Parent | Children sequence |
|--------|------------------|
| Spectre' (8 children) | Spectre, Spectre, Spectre, Spectre, Spectre, Spectre, Spectre, Mystic |
| Mystic' (7 children) | Spectre, Spectre, Spectre, Spectre, Spectre, Spectre, Mystic |

### IOP enforcement cost

| Metric | Hat | Spectre |
|--------|-----|---------|
| Extra Merkle proofs per query | **0** | **0** |
| Extra scalar comparisons per child | 1 | 1 |
| Avg children checked per query | 5.5 | 7.5 |
| Confusable-type tile fraction | 59.1% | 100.0% |

### How it detects swaps

After a P'↔F' swap:
- Hat: the F'-labeled tile presents P'-slot children `[F, H, P, H, F]` (5 children) instead of the F'-slot sequence `[F, H, P, H, F, F]` (6 children) — position check FAILS at position 5
- Spectre: the Spectre'-labeled tile presents Mystic'-slot children (7 children) instead of the Spectre'-slot sequence (8 children) — position check FAILS at position 7

### Relationship to existing composition check

The existing IOP composition (multiset) check verifies the right *counts* of each child type. The canonical check verifies the right *sequence*. Canonical is strictly stronger: a passed canonical check implies a passed composition check, but not vice versa.

### Conclusion

The canonical form check eliminates the IOP blindness demonstrated in #31 with no proof size increase and O(children_per_query) extra work per verification round. Both hat and spectre inflation rules are fully deterministic, making the canonical check well-defined for both systems.

## Confusable Pairs Are Exactly the Unit-Vector Row Differences in the Substitution Matrix (#18)

The substitution matrix rows predict confusable type pairs with no false positives or false negatives: a pair (A, B) is confusable iff their rows differ by exactly one unit vector.

### Hat (4×4 matrix, order: H, T, P, F)

| Type | H | T | P | F |
|------|---|---|---|---|
| H'   | 3 | 1 | 3 | 3 |
| T'   | 1 | 0 | 0 | 0 |
| P'   | 2 | 0 | 1 | 2 |
| F'   | 2 | 0 | 1 | 3 |

Row differences for all pairs:

| Pair | Difference vector | Unit vector? | Confusable? |
|------|-------------------|--------------|-------------|
| H'↔T' | [2,1,3,3] | No | No |
| H'↔P' | [1,1,2,1] | No | No |
| H'↔F' | [1,1,2,0] | No | No |
| T'↔P' | [1,0,1,2] | No | No |
| T'↔F' | [1,0,1,3] | No | No |
| **P'↔F'** | **[0,0,0,1]** | **Yes (one F)** | **Yes ✓** |

Exactly one confusable pair predicted: P'↔F'. This matches the known vulnerability.

### Spectre (2×2 matrix, order: Spectre, Mystic)

| Type | Spectre | Mystic |
|------|---------|--------|
| Spectre' | 7 | 1 |
| Mystic'  | 6 | 1 |

| Pair | Difference vector | Unit vector? | Confusable? |
|------|-------------------|--------------|-------------|
| **Spectre'↔Mystic'** | **[1,0]** | **Yes (one Spectre)** | **Yes ✓** |

### Why this is the right condition

A sibling swap between supertile types A and B requires that a valid B can be constructed from A's children by moving exactly one child tile. Moving one child of type X changes A's row count for X by −1 and B's row count for X by +1. For both resulting compositions to remain valid supertile types, A's row after adding X must equal B's row, and B's row after removing X must equal A's row. This is exactly the unit-vector difference condition: `row_A + e_X = row_B`.

### Corollary: hat-turtle

Hat-turtle delegates to hat's composition matrix, so it has the same single confusable pair P'↔F'. The prediction carries over unchanged.

### Implication

Given the substitution matrix alone, one can enumerate all confusable pairs in O(n²) time (n = number of tile types) by checking all row pairs for unit-vector differences. No geometry or inflation rule walk needed.

## IOP Proof Size Scaling Curve (#20)

Measured with 8 queries per round, BLS12-381 field (32-byte field elements, 32-byte Merkle hashes).

### Hat system

| depth | base_tiles | proof_KB | commit_B | challenge_B | query_B | max_path | openings |
|-------|-----------|---------|---------|------------|--------|---------|---------|
| 1 | 10 | 14.9 | 64 | 128 | 15,040 | 4 | 88 |
| 2 | 64 | 27.8 | 96 | 256 | 28,040 | 6 | 143 |
| 3 | 442 | 49.4 | 128 | 384 | 50,040 | 9 | 209 |
| 4 | 3,025 | 79.1 | 160 | 512 | 80,248 | 12 | 281 |
| 5 | 20,737 | 99.9 | 192 | 640 | 101,408 | 15 | 320 |

### Spectre system

| depth | base_tiles | proof_KB | commit_B | challenge_B | query_B | max_path | openings |
|-------|-----------|---------|---------|------------|--------|---------|---------|
| 1 | 8 | 10.0 | 64 | 64 | 10,048 | 3 | 72 |
| 2 | 63 | 26.4 | 96 | 128 | 26,760 | 6 | 143 |
| 3 | 496 | 49.5 | 128 | 192 | 50,288 | 9 | 214 |
| 4 | 3,905 | 79.0 | 160 | 256 | 80,480 | 12 | 284 |
| 5 | 30,744 | 116.4 | 192 | 320 | 118,672 | 15 | 358 |

### Scaling analysis

The query_B component dominates (>99% of proof size). Commitments and challenges are negligible.

**Max Merkle path depth** grows by ~3 bits per depth level (consistent with branching factor ~5.5–7.5 → log₂(5.5)≈2.5 to log₂(7.5)≈2.9 bits per level).

**Proof size growth per depth level** is approximately linear: each added level contributes the same marginal cost because:
1. It adds one new query round (small — root level has 1 tile)
2. All existing rounds' Merkle paths grow by ~3 hashes (the new base level is larger)

**Hat vs spectre diverge at depth 5**: hat plateaus slightly below 100 KB while spectre grows to 116 KB. Spectre's higher branching factor (7.5 avg vs 5.5 avg) means deeper Merkle paths and more children per opening.

**Proof size formula**: `proof_bytes ≈ Q × ∑_{k=1}^{d} (1 + avg_children_k) × (field_el + merkle_path_k × hash_size)` where `merkle_path_k ≈ ceil(log₂(tiles_at_level_{k-1}))` and `tiles_at_level_k ≈ λ^(d-k)` (λ = dominant eigenvalue).

## Steganographic Bit Channel in Sibling-Swap Ambiguity (#27)

Each sibling confusable pair (P'↔F' for hat, Spectre'↔Mystic' for spectre) is a 1-bit covert channel: canonical labeling encodes 0, swapped labeling encodes 1. The channel is undetectable by the pre-#33 IOP and completely closed by the #33 canonical check.

### Channel capacity (depth 4, seed H/Spectre)

| System | Swap instances | Capacity (bits) | Capacity (bytes) | Growth rate per depth |
|--------|---------------|-----------------|------------------|-----------------------|
| Hat | 351 | 351 | 43 | ~6.9× (≈ λ_hat = 6.86) |
| Spectre | 495 | 495 | 61 | ~8.0× (≈ λ_spectre = 7.87) |

**Capacity by level (hat, depth 4):**

| Level | Instances | Bits |
|-------|-----------|------|
| 1 (base supertiles) | 300 | 300 |
| 2 | 42 | 42 |
| 3 | 9 | 9 |
| Total | 351 | 351 |

### Encode/decode demonstration

Message `"hello"` (5 bytes = 40 bits) encoded in a depth-4 hat hierarchy:
- 40/351 = 11% of capacity used
- 21 swap operations applied (bits set to 1)
- Decoded: `"hello"` — match ✓

### Detectability

| Verifier | Detection |
|----------|-----------|
| Pre-#33 IOP (composition check only) | **Undetectable** — all swap variants pass as valid |
| Post-#33 IOP (canonical check added) | **Fully detectable** — any swapped instance fails position check; 0 bits survive |

### Why capacity scales at λ

Each depth level adds a factor of λ (dominant substitution eigenvalue) more sibling pairs, because the number of same-parent P'/F' pairs grows proportionally to the tile count, which grows at λ per level. The channel capacity doubles roughly every log₂(λ) ≈ 2.8 depth levels.

### Implication

The sibling-swap ambiguity creates a covert channel with capacity growing exponentially in hierarchy depth. The #33 canonical check completely eliminates this channel: any stego bit is immediately detectable as a child-type mismatch at the corresponding hierarchy node.

## Local-to-Global Gap Closes at Radius = Depth (#16)

The local-to-global gap closing radius equals the hierarchy depth exactly, for both hat and spectre across all tested depths.

| System | depth 3 | depth 4 | depth 5 | depth 6 |
|--------|---------|---------|---------|---------|
| Hat | closes r=3 | closes r=4 | closes r=5 | closes r=6 |
| Spectre | closes r=3 | closes r=4 | closes r=5 | closes r=6 |

The pattern holds without exception: gap closing radius = depth.

**Interpretation**: to verify that a tile is globally consistent with the full hierarchy, you must propagate the check upward through all `depth` levels of the substitution hierarchy. At each level, the local neighborhood of valid context expands by one "supertile radius." A neighborhood of radius `depth` is exactly the smallest window that reaches the root — no smaller window can guarantee global consistency, and radius `depth` is always sufficient.

**Consequence for IOP**: this confirms that the query radius for the tiling IOP scales linearly with depth, not super-linearly. The IOP's depth × queries complexity matches the O(depth) closing radius.

## Minimum Useful Patch Size for Recovery (#19)

Recovery succeeds perfectly (all erased tiles matched) only for holes of at most 3 tiles (radius ≤ 1.5). Beyond that threshold, recovery becomes partial.

### Results (levels=3, hat H-patch, 442 total tiles)

| radius | erased | matched | unmatched | match rate |
|--------|--------|---------|-----------|-----------|
| 0.5 | 1 | 1 | 0 | 100% ✓ |
| 1.0 | 3 | 3 | 0 | 100% ✓ |
| 1.5 | 3 | 3 | 0 | 100% ✓ |
| 2.0 | 9 | 3 | 6 | 33% ✗ |
| 3.0 | 17 | 3 | 14 | 18% ✗ |
| 4.0 | 27 | 3 | 24 | 11% ✗ |
| 5.0 | 43 | 3 | 40 | 7% ✗ |

**The threshold is at 3 erased tiles.** The recovery algorithm (deflation-based) reliably reconstructs up to 3 contiguous missing tiles. At 9 or more, the hole is too large for the local deflation context to fully close.

**Depth independence**: the match rate does not depend on the `levels` parameter at the same radius — the recovery is determined by the geometric hole size, not the total patch size. The context (99%+ of tiles remaining) is always sufficient; the limit is the algorithm's local search radius.

**Extra recovered tiles**: the deflation-based recovery always regenerates a large superpatch (251 tiles at 3 levels of deflation). Only 1–3 of these overlap with the original hole positions. The rest are "bonus" tiles outside the erased region.

## IOP Tamper Detection Under Substitution Noise (#24)

The IOP detects arbitrary type substitutions at the base level (non-sibling type changes) whenever the tampered tile is queried. Detection scales with tamper rate and query coverage.

### Detection rates (depth=3, 8 queries, 50 trials)

**Hat:**

| tamper rate | detected | not detected | detection rate |
|-------------|----------|-------------|----------------|
| 0% | 0/50 | 50/50 | 0.0% (baseline) |
| 1% | 19/50 | 31/50 | 38.0% |
| 2% | 38/50 | 12/50 | 76.0% |
| 5% | 46/50 | 4/50 | 92.0% |
| 10% | 50/50 | 0/50 | **100.0%** |
| 20% | 50/50 | 0/50 | 100.0% |
| 50% | 50/50 | 0/50 | 100.0% |

**Spectre:**

| tamper rate | detected | not detected | detection rate |
|-------------|----------|-------------|----------------|
| 0% | 0/50 | 50/50 | 0.0% (baseline) |
| 1% | 22/50 | 28/50 | 44.0% |
| 2% | 35/50 | 15/50 | 70.0% |
| 5% | 49/50 | 1/50 | 98.0% |
| 10% | 50/50 | 0/50 | **100.0%** |
| 20% | 50/50 | 0/50 | 100.0% |
| 50% | 50/50 | 0/50 | 100.0% |

### Detection mechanism

The `verify_fold` function checks both (1) the multiset composition (child type counts must match the claimed parent type's expected composition) and (2) the folding value. A base-level type flip changes the child's type reported to the verifier, which changes the actual child-type counts and breaks the composition check for that parent.

**Why some trials escape detection**: with 8 queries over ~442–496 base tiles, roughly 8×avg_children ≈ 60 parent-child pairs are checked per round. At 1% tamper rate (~5 flipped tiles), the probability that at least one changed tile is checked = 1 − (1 − 5/496)^60 ≈ 46%. The observed rates (38–44%) match this analytical estimate.

**10% tamper is the saturation threshold**: at 10% tamper rate (~50 flipped tiles), detection probability per trial = 1 − (1 − 50/496)^60 > 99.99%, so all 50 trials are detected.

### Contrast with sibling swaps (#31)

Base-level type flips (even P→F or Spectre→Mystic) ARE detected because they break composition at the parent level. The undetectable case from #31 is specifically SUPERTILE-LEVEL label swaps between sibling P'/F' pairs, where both siblings are already valid children of the same parent — the multiset is unchanged.
