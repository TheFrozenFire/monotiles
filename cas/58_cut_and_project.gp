/* Issue #58: Cut-and-project lift — hat tiling as 4D model set
 *
 * Hypothesis: tile types H/T/P/F correspond to regions (acceptance windows)
 * in a 4D internal space.  The windows are polygons with LINEAR boundaries,
 * making the type indicator a degree-1 function in the internal coordinate.
 *
 * Builds on:
 *   #49 — substitution matrix, Q(√5) number field, Perron eigenvalue φ⁴
 *   #53 — coordinate ring Z[ω], Eisenstein integers, hexagonal lattice
 *
 * Hat substitution matrix (row i = composition of supertile i):
 *   M[H,·] = [3,1,3,3]   (H → 3H + 1T + 3P + 3F)
 *   M[T,·] = [1,0,0,0]   (T → 1H)
 *   M[P,·] = [2,0,1,2]   (P → 2H + 1P + 2F)
 *   M[F,·] = [2,0,1,3]   (F → 2H + 1P + 3F)
 */

x  = 'x;
s5 = sqrt(5);
s3 = sqrt(3);

/* ── Part 1: Golden ratio — the inflation direction ─────────────────── */

print("=== Part 1: Golden ratio algebra (inflation direction) ===");

phi   = (1 + s5) / 2;   /* φ ≈ 1.618   linear inflation factor          */
phi_p = (1 - s5) / 2;   /* φ' ≈ -0.618 Galois conjugate (the small root) */
phi2  = phi * phi;       /* φ² = φ+1 = (3+√5)/2 ≈ 2.618  (area scale)  */
phi2p = phi_p * phi_p;   /* (φ²)' = (3-√5)/2 ≈ 0.382                    */

print("φ   = (1+√5)/2 ≈ ", phi);
print("φ'  = (1-√5)/2 ≈ ", phi_p,  "  (Galois conjugate)");
print("φ²  = (3+√5)/2 ≈ ", phi2,   "  (area inflation factor, used in geometry.rs)");
print("(φ²)' = (3-√5)/2 ≈ ", phi2p);
print("φ·φ' = ", phi*phi_p, " = -1  (product of roots of x²-x-1=0)");
print("φ+φ' = ", phi+phi_p, " =  1  (sum of roots)");
print("");
print("Pisot property: |φ'| = ", abs(phi_p), " < 1");
print("  → σ maps inflation-scale positions to SMALL internal coords.");
print("  → Internal positions are dense in a BOUNDED window as n→∞.");
print("  → This guarantees the cut-and-project scheme is a genuine model set.");

/* Perron root of hat substitution matrix: (7+3√5)/2 = φ⁴ */
lambda_hat = (7 + 3*s5) / 2;
print("\nPerron root of hat substitution matrix:");
print("  λ = (7+3√5)/2 ≈ ", lambda_hat);
print("  φ⁴ = ((1+√5)/2)⁴ = ", phi^4, "  [check: φ⁴ = φ² · φ² = (φ+1)² = φ²+2φ+1 = 3φ+2]");
print("  → λ = φ⁴  exactly  (metatile count grows as φ^{4k} per k inflation steps)");

/* Explain the count vs. geometry split */
print("\nCount vs. geometry:");
print("  Geometric linear scale: φ (each inflation stretches distances by φ)");
print("  Geometric area scale:   φ² ≈ 2.618  (area of supertile / area of tile)");
print("  Metatile COUNT scale:   φ⁴ ≈ 6.854  (tiles at level k+1 / tiles at level k)");
print("  The extra factor φ² = λ_count / λ_area reflects the increasing metatile");
print("  density: smaller metatiles pack more densely inside each inflation step.");

/* ── Part 2: Hexagonal lattice Z[ω] (recap from #53) ─────────────────── */

print("\n=== Part 2: Hexagonal lattice Z[ω] (recap from #53) ===");
print("ω = e^(iπ/3) = 1/2 + i√3/2, minimal polynomial x²-x+1 (6th cyclotomic)");
print("Z[ω] = Eisenstein integers = ring of integers of Q(√(-3)) = Q(ω)");
print("Norm: N(a+bω) = a²+ab+b²  (squared hexagonal distance from origin)");
print("Units: ±1, ±ω, ±(1-ω)  (6 elements forming D₆ under multiplication)");
print("");
print("Key point for cut-and-project:");
print("  The Galois automorphism σ₅: √5↦-√5 FIXES ω  (since ω involves only √(-3)).");
print("  Physical and internal spaces share the SAME hexagonal geometry Z[ω].");
print("  Only the inflation direction (powers of φ) changes under σ₅.");

/* Gram matrix of Z[ω] basis {1, ω} */
G_hex = [1, 1/2; 1/2, 1];
det_hex = matdet(G_hex);
print("\nGram matrix of {1, ω}: G = [[1, 1/2], [1/2, 1]], det = ", det_hex, " = 3/4");
print("Fundamental domain area = √(3/4) = √3/2 ≈ ", s3/2 + 0.);

/* ── Part 3: 4D lattice Z[φ, ω] ──────────────────────────────────────── */

print("\n=== Part 3: 4D lattice Z[φ, ω] — the full position ring ===");
print("Hat tile vertex positions at all inflation levels live in:");
print("  Z[φ, ω] = Z-span of {1, φ, ω, φω}  ⊂  Q(√5, √(-3))");
print("  Rank as Z-module: 4  (freely generated by {e₁=1, e₂=φ, e₃=ω, e₄=φω})");
print("  Ambient field: Q(√5, √(-3)), degree 4 over Q (from #53)");
print("");
print("Why Z[φ, ω] (not Z[φ², ω])?");
print("  The geometric.rs inflation uses PHI_SQ = φ² as area scale,");
print("  but the VERTEX positions involve φ (linear scale), not φ².");
print("  After one inflation step: new vertices ∈ φ·Z[ω] + Z[ω] = Z[φ, ω]");
print("  since Z[φ] = Z-span of {1, φ} (rank-2 over Z[ω]).");
print("  Z[φ², ω] ⊂ Z[φ, ω] with index 2; we need the larger ring.");

/* Characteristic polynomial of the 4D lattice field Q(√5, √(-3)) */
/* From #53: compositum has min poly x⁴ - 4x² + 64 (for a specific primitive element) */
comp_poly = polcompositum(x^2-5, x^2+3)[1];
print("\nMinimal polynomial of Q(√5, √(-3)) over Q: ", comp_poly);
nf_comp = bnfinit(comp_poly);
print("Discriminant: ", nf_comp.disc, "  Class number: ", nf_comp.clgp.no);
print("Degree: 4, signature: [0, 2] (totally complex)");

/* ── Part 4: Galois map σ₅ (physical → internal projection) ─────────── */

print("\n=== Part 4: Galois map σ₅ — the internal projection ===");
print("The cut-and-project map uses the Galois automorphism σ₅ of Q(√5, √(-3)):");
print("  σ₅: √5 ↦ -√5,  √(-3) ↦ √(-3)  [fixes hexagonal part, negates inflation]");
print("");
print("For z = a + b·φ + (c + d·φ)·ω  ∈  Z[φ, ω]:");
print("  Physical position:  z_phys = z  (standard embedding in C)");
print("  Internal position:  z_int  = σ₅(z) = a + b·φ' + (c + d·φ')·ω");
print("");
print("The 4D embedding π: Z[φ, ω] → C × C ≅ R⁴:");
print("  π(z) = (z_phys, z_int)");
print("  Image: a 4D lattice Λ ⊂ R⁴ whose projection to first two coords is dense.");

/* Explicit basis in R⁴ = (phys_Re, phys_Im, int_Re, int_Im) */
re_omega   = 1/2;
im_omega   = s3/2;
re_phi_p_omega = phi_p * (1/2);
im_phi_p_omega = phi_p * (s3/2);

print("\n4D embedding of basis vectors (phys_Re, phys_Im, int_Re, int_Im):");
print("  π(1)    = (1,   0,   1,   0  )");
print("  π(φ)    = (", phi+0., ",   0,   ", phi_p+0., ",   0  )");
print("  π(ω)    = (1/2, √3/2, 1/2, √3/2)  [σ₅ fixes ω]");
print("  π(φω)   = (", phi/2+0., ", ", phi*s3/2+0., ", ", phi_p/2+0., ", ", phi_p*s3/2+0., ")");

/* 4×4 embedding matrix M (columns = π(basis elements)) */
M_embed = [1, phi, re_omega, phi*re_omega; 0, 0, im_omega, phi*im_omega; 1, phi_p, re_omega, phi_p*re_omega; 0, 0, im_omega, phi_p*im_omega];
det_M = matdet(M_embed + 0.);
print("\n4×4 embedding matrix M (columns = basis vectors in R⁴):");
print("  [[1,    φ,    1/2,   φ/2  ]");
print("   [0,    0,    √3/2,  φ√3/2]");
print("   [1,    φ',   1/2,   φ'/2 ]");
print("   [0,    0,    √3/2,  φ'√3/2]]");
print("det(M) = ", det_M);
print("|det(M)| = ", abs(det_M));

/* Gram matrix and lattice volume */
G4 = mattranspose(M_embed) * M_embed;
vol4 = sqrt(abs(matdet(G4) + 0.));
print("\nGram matrix G = Mᵀ·M:");
print(G4 + 0.);
print("det(G) = ", matdet(G4)+0.);
print("4D fundamental domain volume = √|det(G)| = ", vol4);

/* ── Part 5: Sample internal coordinates ──────────────────────────────── */

print("\n=== Part 5: Sample internal coordinates ===");
print("For a tile at position z ∈ Z[φ, ω], internal coord = σ₅(z).");
print("");
print("Level-0 tiles: z = a + b·ω  (no φ component)");
print("  σ₅(a + bω) = a + bω  (identical — windows not yet separated!)");
print("  At level 0, physical = internal → ALL level-0 tiles fall in W_ALL.");
print("");

/* Level-1: the seed H-type supertile has 10 children at φ-scaled positions */
print("Level-1 tiles: z = a + b·ω + c·φ  (one inflation step)");
print("  σ₅(z) = a + b·ω + c·φ'  where φ' ≈ ", phi_p);
print("  |int coord| ≤ |phys coord| × |φ'/φ| = |phys coord| × ", abs(phi_p/phi)+0.);
print("  The internal coordinate is COMPRESSED by factor 1/φ² ≈ ", 1/phi2+0.);
print("");
print("Level-n tiles: z = z₀ + c·φⁿ  for some z₀ ∈ Z[ω], c ∈ Z[ω]");
print("  σ₅(z) = z₀ + c·(φ')ⁿ  → convergent as n→∞ since |φ'| < 1");
print("  The internal coordinate is bounded:  |σ₅(z)| ≤ |z₀| + |c|/(1-|φ'|)");

/* Numerical illustration: apply σ to the level-1 child offset (one φ step) */
z_phys = phi + 0*1;     /* the simplest level-1 position: φ itself */
z_int  = phi_p + 0.;    /* its internal coordinate: φ' */
print("\nExample: level-1 position z = φ");
print("  Physical: z_phys = φ ≈ ", z_phys);
print("  Internal: z_int  = φ' ≈ ", z_int);
print("  |z_int / z_phys| = ", abs(z_int / z_phys), " = 1/φ² ≈ ", 1/phi2+0.);

/* ── Part 6: Tile frequencies = window area ratios ────────────────────── */

print("\n=== Part 6: Tile frequencies and window area ratios ===");
print("Model set theorem: Area(W_τ) / Area(W_total) = f_τ (tile frequency).");
print("Tile frequencies = components of the Perron LEFT eigenvector of M.");
print("");

M_hat = [3,1,3,3; 1,0,0,0; 2,0,1,2; 2,0,1,3];

/* From cas/54_swap_density.gp (already verified there) */
v_H = 1;
v_T = (7 - 3*s5) / 2;
v_P = -6 + 3*s5;
v_F = (9 - 3*s5) / 2;
v_tot = v_H + v_T + v_P + v_F;

print("Exact frequencies from Perron eigenvector of Mᵀ:");
print("  f_H (unnorm) = 1");
print("  f_T (unnorm) = (7-3√5)/2  ≈ ", v_T+0.);
print("  f_P (unnorm) = -6+3√5     ≈ ", v_P+0.);
print("  f_F (unnorm) = (9-3√5)/2  ≈ ", v_F+0.);
print("  Sum           = ", v_tot+0.);

/* Verify: Mᵀ v = λ v */
v_freq = [v_H, v_T, v_P, v_F]~;
Mv = mattranspose(M_hat) * v_freq;
err = norml2(Mv - lambda_hat * v_freq + 0.);
print("\nVerify Mᵀ·v = λ·v:  max error = ", err, "  (should be < 1e-12)");

/* Normalized ratios */
f_H = v_H / v_tot;
f_T = v_T / v_tot;
f_P = v_P / v_tot;
f_F = v_F / v_tot;
print("\nNormalized tile frequencies (= window area fractions):");
print("  H:  ", f_H+0.,  "  ( = 1 / (sum) )");
print("  T:  ", f_T+0.,  "  = (7-3√5)/2 / (sum)");
print("  P:  ", f_P+0.,  "  = (-6+3√5)  / (sum)");
print("  F:  ", f_F+0.,  "  = (9-3√5)/2 / (sum)");
print("  Total: ", (f_H+f_T+f_P+f_F)+0.,  "  ✓");

/* Area of total window W_total */
/* Density formula for model sets: dens × vol(W) = 1 where dens = volume(R⁴ fund. domain)^{-1} */
/* Area(W_total) = |det(M_embed)| / Area(Z[ω] fund. domain) */
/* This is the density of the tiling expressed as tiles per unit area in physical space. */
area_fund_omega = s3/2;   /* fundamental domain of Z[ω] in C */
area_W_total = abs(det_M) / area_fund_omega;
print("\nTotal acceptance window area:");
print("  Area(W_total) = |det(M_embed)| / Area(Z[ω] fund. domain)");
print("  = ", abs(det_M), " / ", area_fund_omega+0., " = ", area_W_total+0.);
print("\nIndividual window areas:");
print("  Area(W_H) ≈ ", (f_H * area_W_total)+0.);
print("  Area(W_T) ≈ ", (f_T * area_W_total)+0.);
print("  Area(W_P) ≈ ", (f_P * area_W_total)+0.);
print("  Area(W_F) ≈ ", (f_F * area_W_total)+0.);

/* ── Part 7: Linearity of window boundaries ────────────────────────────── */

print("\n=== Part 7: Linearity of acceptance window boundaries ===");
print("Claim: the type indicator T: C_int → {H,T,P,F} has LINEAR boundaries.");
print("");
print("Proof sketch (model set theory):");
print("  1. Hat tiles are polykites — polygons on the triangular grid Z[ω].");
print("  2. Each tile has a FINITE set of vertices in Z[φ,ω].");
print("  3. The cut-and-project window W_τ for type τ is the closure of:");
print("     { σ₅(v) : v is the 'characteristic vertex' of a type-τ tile }");
print("  4. Since Z[φ,ω] is a lattice in R⁴ and σ₅ is linear, the image is");
print("     a discrete set; its closure is a POLYTOPE (bounded by finitely many");
print("     hyperplanes = linear constraints).");
print("  5. In 2D internal space, a polytope is a POLYGON.");
print("  → Type indicator = step function on a POLYGONAL partition of W_total.");
print("  → Each boundary segment is a LINEAR FORM L(Re(w), Im(w)) = 0.");
print("");
print("Formal statement:");
print("  ∃ linear forms Lᵢ: C → R  such that:");
print("  W_τ = { w ∈ C_int : Lᵢ(w) ≥ 0 for all constraints i associated with τ }");
print("  where Lᵢ(a+bi) = pᵢ·a + qᵢ·b + rᵢ  for pᵢ,qᵢ,rᵢ ∈ Q(√5).");
print("");
print("Degree: the type indicator is piecewise-constant with DEGREE-1 (linear) boundaries.");
print("In polynomial terms: T(w) cannot be expressed as a polynomial, but the");
print("MEMBERSHIP PREDICATE 'w ∈ W_τ' is a conjunction of LINEAR inequalities.");
print("This is analogous to: 'x is an integer in [0,p)' is determined by floor(x)");
print("which, while not polynomial, has linear-boundary level sets.");

/* ── Part 8: Implication for IOP and FRI-proximity ────────────────────── */

print("\n=== Part 8: FRI-proximity gap analog for the hat IOP ===");
print("The hat tiling has an RS-proximity-gap analog via the 4D cut-and-project:");
print("");
print("Step 1: Extend the leaf commitment.");
print("  Each leaf (tile position z) gets an extra field element: σ₅(z) ∈ Z[ω].");
print("  This is the INTERNAL COORDINATE, computable from z by the Galois map.");
print("  Commitment: (z, σ₅(z), type) with a polynomial commitment binding σ₅(z).");
print("");
print("Step 2: Type membership as a linear constraint.");
print("  The verifier checks: σ₅(z) ∈ W_type(z)  using the window's linear inequalities.");
print("  This is O(1) per tile (constant number of linear constraints per window).");
print("");
print("Step 3: Proximity gap formulation.");
print("  Define 'valid tiling' as: ALL tiles satisfy (z, σ₅(z)) ∈ W_type  AND");
print("  neighboring tiles have geometrically consistent positions (via IOP).");
print("  A 'δ-close' invalid tiling must violate at least one window membership check.");
print("  Soundness: the probability that a random verifier query catches a violation");
print("  is at least δ × (query coverage rate).");
print("");
print("Step 4: Reduction to FRI.");
print("  Over a prime field F_p (with p ≡ 1 mod 15 to split Z[φ,ω]):");
print("  σ₅ becomes a field automorphism of (F_p)⁴; window membership becomes");
print("  a conjunction of F_p linear constraints.");
print("  This is exactly the setting of proximity-gap proofs for linear codes!");

/* ── Part 9: Good primes for the F_p reduction ────────────────────────── */

print("\n=== Part 9: Good primes for F_p reduction ===");
print("We need primes p such that:");
print("  (a) p splits completely in Q(√5)  → p ≡ 1 mod 5");
print("  (b) p splits completely in Q(√(-3)) → p ≡ 1 mod 3");
print("Combined: p ≡ 1 mod 15  (by CRT, since gcd(5,3)=1)");
print("");
good_primes = select(p -> (p%15==1), primes(200));
print("Primes p ≡ 1 mod 15 (split completely in Q(√5, √(-3))):");
print("  ", good_primes);
print("");
print("Smallest good prime: ", good_primes[1]);
print("For p =", good_primes[1], ": Z[φ,ω]/(p) ≅ (Z/p)⁴  [splits into 4 copies]");
print("  The Galois map σ₅ becomes a permutation matrix over (Z/p)⁴.");
print("  Window membership checks reduce to linear algebra over Z/p.");
print("");
print("Next few good primes: ", vecextract(good_primes, "1..8"));

/* Verify splitting for the smallest good prime */
p1 = good_primes[1];
print("\nVerify splitting of p =", p1, " in Q(√5):");
print("  √5 mod", p1, ": solve x²≡5 mod", p1);
/* Find square root of 5 mod p1 */
r5 = Mod(5, p1);
sqrt5_mod_p1 = sqrt(r5);
print("  √5 ≡ ", lift(sqrt5_mod_p1), " mod ", p1, "  → p splits in Q(√5) ✓");

print("\nVerify splitting of p =", p1, " in Q(√(-3)):");
r3 = Mod(-3, p1);
sqrt_neg3 = sqrt(r3);
print("  √(-3) ≡ ", lift(sqrt_neg3), " mod ", p1, "  → p splits in Q(√(-3)) ✓");

/* ── Part 10: Open questions ──────────────────────────────────────────── */

print("\n=== Part 10: Open questions ===");
print("1. EXPLICIT WINDOW VERTICES: compute the exact vertices of W_H, W_T, W_P, W_F");
print("   → Requires exact hat tile vertex positions in Z[φ, ω].");
print("   → Current codebase: approximate floating-point positions only.");
print("   → Next step: derive exact coordinates from the polykite construction.");
print("");
print("2. WINDOW SHAPE: are W_τ convex? Simply connected? What is their symmetry group?");
print("   → The full tiling has D₆ symmetry; windows inherit Z/6Z symmetry.");
print("   → Convexity is NOT guaranteed (depends on the acceptance domain definition).");
print("");
print("3. MINIMUM DISTANCE TO WINDOW BOUNDARY:");
print("   dist_τ = inf { d(σ₅(z), ∂W_τ) : z has type τ }");
print("   → This is the 'proximity gap parameter' for the hat IOP.");
print("   → Governs soundness error: verifier catches violations with prob ≥ dist_τ/diam(W).");
print("");
print("4. SPECTRE ANALOG:");
print("   → Spectre has 2 types (Spectre/Mystic) with eigenvalue (4+√15)/2 ∈ Q(√15).");
print("   → Cut-and-project for spectre: replace Q(√5) by Q(√15), same Z[ω] hex lattice.");
print("   → Spectre has no reflected tiles → smaller symmetry group → potentially larger gap.");
print("   → Good primes for spectre: p ≡ 1 mod 15 still (since 15 = 3·5)? No: need p ≡ 1 mod 3 and Q(√15) split.");
print("   → Q(√15): p splits iff p is a QR mod 15. Check: Legendre symbols (p|3) and (p|5).");
print("   → p ≡ 1 mod 3 AND (5|p) = 1 → p ≡ 1,4 mod 5. Combined: p ≡ 1,4 mod 5 AND p ≡ 1 mod 3.");
spectre_good = select(p -> (p%3==1) && ((p%5==1) || (p%5==4)), primes(200));
print("   Good primes for spectre (p splits in Q(√15,√(-3))):");
print("   ", vecextract(spectre_good, "1..10"));

/* ── Summary ──────────────────────────────────────────────────────────── */

print("\n=== Summary ===");
print("Hat tiling cut-and-project structure:");
print("  Coordinate ring:    Z[φ, ω]  (rank-4 Z-module, ⊂ Q(√5, √(-3)))");
print("  Physical space:     C ≅ R²   (tile positions)");
print("  Internal space:     C ≅ R²   (Galois-conjugate of positions)");
print("  Galois map:         σ₅: φ ↦ φ' = (1-√5)/2,  ω ↦ ω");
print("  Pisot condition:    |φ'| = (√5-1)/2 ≈ ", abs(phi_p), " < 1  ✓");
print("");
print("Acceptance windows W_τ ⊂ C_int for τ ∈ {H, T, P, F}:");
print("  Area ratios = tile frequencies from Perron eigenvector:");
print("    H : T : P : F ≈ ", f_H+0., " : ", f_T+0., " : ", f_P+0., " : ", f_F+0.);
print("  Window boundaries are LINEAR (polygonal): degree-1 type indicator.");
print("");
print("Cryptographic implication:");
print("  Extend leaf commitments with σ₅(z) ∈ Z[ω].");
print("  Type check = O(1) linear inequalities in the internal coordinate.");
print("  Reduces to FRI proximity gap over F_p for p ≡ 1 mod 15.");
print("    Smallest such prime: p = ", good_primes[1]);
print("");
print("Open: explicit window vertices and minimum gap (proximity parameter).");
